<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS animation 属性</title>
    <url>/2020/07/26/CSS-animation-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>animation 属性和 transition 属性都将可以用来制作 CSS 动画，但是 animation 相比 transition 可以实现更加复杂灵活的动画，而且可以自行触发，不需要事件来触发就能动起来，还能重复发生，通常用来实现复杂的动画效果。</p>
<p>语法:  动画名称 动画时间 速度曲线 延迟时间 动画次数 是否反向播放动画;</p>
<a id="more"></a>
<p><code>animation: name duration timing-function delay iteration-count direction;</code><br>我们在 animation 属性中要把我们定义的动画的名称捆绑上且规定动画的时长，才能产生动画效果。<br>我们通过 <code>@keyframes</code> 来定义动画名称和动画的具体过程。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="attribute">animation</span>: changecolor <span class="number">3s</span> ease <span class="number">3s</span> <span class="number">2</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> changecolor &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="box"></div>

<p>如上，我们 用 <code>@keyframes</code> 定义了一个 名称为  <code>changecolor</code> 的动画，动画过程是挂载该动画的元素的背景颜色从红色变为蓝色,宽度从 100px 变为 200px。然后我们把该动画捆绑到 .box 选择器上，即 animation 的动画名称设置为 <code>changecolor</code>，动画时长为 3s，速度曲线为 ease，延迟时间 3s，动画次数 2 次。整个动画过程就是，延迟 3s 后黄色的正方形瞬间会变成红色然后在 3s 时间内背景颜色变为蓝色，宽度也会变为 600px。且变化过程会重复两次。动画结束后，盒子会变为原来的黄色正方形盒子。</p>
<p>我们也可以用百分比来规定发生变化的时间。0% 是动画的开始，100% 是动画的完成。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> movecolor &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  25% &#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  75% &#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="main-box1">
  <div class="box1"></div>
</div>

<p>上面的例子我们设置 <code>animation: movecolor 4s infinite;</code><br>动画时间是 4s，盒子从 (0, 0) 到 (200, 0) 到 (200, 100) 到 (0, 100) 最后回到 (0, 0) 点。可以分为 四个时间点。100% / 4 是 25%，所以我们每隔 25% 的动画时间就设置一次变化。也就是 0% 25% 50% 75% 100% 各加一次变化。因为最后是回到了原点 (0, 0)，所以 0% 和 100% 可以写到一起。如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> movecolor &#123;</span><br><span class="line">  0%, 100%&#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  25% &#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  75% &#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-的子属性"><a href="#animation-的子属性" class="headerlink" title="animation 的子属性"></a>animation 的子属性</h3><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_animation-name.asp" target="_blank" rel="noopener external nofollow noreferrer">animation-name</a></td>
<td>规定需要绑定到选择器的 keyframe(动画) 名称。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_animation-duration.asp" target="_blank" rel="noopener external nofollow noreferrer">animation-duration</a></td>
<td>规定完成一个动画周期所花费的时间，以秒或毫秒计。默认 0</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_animation-timing-function.asp" target="_blank" rel="noopener external nofollow noreferrer">animation-timing-function</a></td>
<td>规定动画的速度曲线，默认 ease</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_animation-delay.asp" target="_blank" rel="noopener external nofollow noreferrer">animation-delay</a></td>
<td>规定在动画开始之前的延迟，默认 0</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_animation-iteration-count.asp" target="_blank" rel="noopener external nofollow noreferrer">animation-iteration-count</a></td>
<td>规定动画应该播放的次数，默认 1，infinite 为动画无限次播放</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/cssref/pr_animation-direction.asp" target="_blank" rel="noopener external nofollow noreferrer">animation-direction</a></td>
<td>规定是否应该轮流反向播放动画，默认 normal，alternate    动画应该轮流反向播放。</td>
</tr>
</tbody></table>
<h5 id="1-animation-timing-function-速度曲线"><a href="#1-animation-timing-function-速度曲线" class="headerlink" title="1.  animation-timing-function 速度曲线"></a>1.  animation-timing-function 速度曲线</h5><p>这个属性和 transition 的是一样的，也就是：  </p>
<ul>
<li>linear ——    动画从头到尾的速度是相同的。    测试</li>
<li>ease ——    默认。动画以低速开始，然后加快，在结束前变慢。    测试</li>
<li>ease-in ——    动画以低速开始。    测试</li>
<li>ease-out ——    动画以低速结束。    测试</li>
<li>ease-in-out ——    动画以低速开始和结束。    测试</li>
<li>cubic-bezier(n,n,n,n) ——    在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。</li>
</ul>
<h5 id="2-animation-iteration-count-动画播放次数"><a href="#2-animation-iteration-count-动画播放次数" class="headerlink" title="2.  animation-iteration-count 动画播放次数"></a>2.  animation-iteration-count 动画播放次数</h5><p>我们想让动画播放几次就写几，想无限循环播放，就写 infinite，如我们把上面的例子改为 infinite</p>
<div class="box2"></div>

<h5 id="3-animation-direction-动画是否轮流反向播放"><a href="#3-animation-direction-动画是否轮流反向播放" class="headerlink" title="3.  animation-direction 动画是否轮流反向播放"></a>3.  animation-direction 动画是否轮流反向播放</h5><p>我们设置 animation-direction 属性的值为 normal 时，动画正常播放，设置为 alternate 时，动画在每次完成一次动画周期后，都会反向再次播放这个动画，具体效果如下</p>
<div class="box3"></div>
<br/>

<p>此时的 animation 设置为：<code>animation: changecolor 3s ease 3s infinite alternate;</code><br>需要注意的是这里的反向播放是要计算动画播放次数的，也就是奇数次播放是正常的，偶数次播放是反向的。如果我们设置动画次数为一次，animation-direction 属性就算设置为 alternate 也不会反向播放。<br>如下面的 animation 设置为： <code>animation: changecolor 3s ease 3s  alternate;</code><br>就只会播放一次。</p>
<div class="box4"></div>

<h5 id="4-animation-delay-规定在动画开始之前的延迟。"><a href="#4-animation-delay-规定在动画开始之前的延迟。" class="headerlink" title="4.  animation-delay    规定在动画开始之前的延迟。"></a>4.  animation-delay    规定在动画开始之前的延迟。</h5><p>animation-delay    这个属性就是规定在动画开始之前的延迟，很简单的一个属性，你想一段时间后才运行动画，设置这个属性就行。但是，这个属性也有一些很巧妙的用法。和第二个例子一样，让一个小球在一个盒子里做 “回”字运动，但不同的是我们想让四个小球完成如下的运动。</p>
<style>
  .box {
    width: 100px;
    height:100px;
    background-color: yellow;
    animation: changecolor 3s ease 3s 2; 
  }

  .main-box1 {
    position: relative;
    height: 200px;
  }

  .box1 {
    position: relative;
    width: 100px;
    height:100px;
    background-color: yellow;
    animation: movecolor 4s ease infinite; 
  }

  .box2 {
    width: 100px;
    height:100px;
    background-color: yellow;
    animation: changecolor 3s ease 3s infinite; 
  }

  .box3 {
    width: 100px;
    height:100px;
    background-color: yellow;
    animation: changecolor 3s ease 3s infinite alternate; 
  }

  .box4 {
    width: 100px;
    height:100px;
    background-color: yellow;
    animation: changecolor 3s ease 3s alternate; 
  }

  @keyframes changecolor {
    from {
      width: 100px;
      background-color: red;
    }
    to {
      width: 600px;
      background-color: blue;
    }
  }

  @keyframes movecolor {
    0%, 100% {
      left:0px;
      top:0px;
    }
    25% {
      left:200px;
      top:0px;
    }
    50% {
      left:200px;
      top:100px;
    }
    75% {
      left:0px;
      top:100px;
    }
  }

  .main-circle {
    position: relative;
  }

  .container-circle {
    position: relative;
    width: 120px;
    height: 120px;
    left: calc(50% - 60px);
  }

  .container-circle div{
    height: 40%;
    width: 40%;
    border-radius: 50%;
    position: absolute;
    text-align: center;
    line-height: 48px;
    font-size: 20px;
    animation: loading 2s ease infinite; 
  }

  .container-circle :first-child {
    background: #4101d5;
  }
  .container-circle :nth-child(2) {
    background: #fffc44;
    animation-delay: -0.5s; 
  }
  .container-circle :nth-child(3) {
    background: #a439eb;
    animation-delay: -1s; 
  }
  .container-circle :last-child {
    background: #cf94f7;
    animation-delay: -1.5s; 
  }

  .container2 div{
    animation-play-state: paused;
  }

  .container2 :first-child {
    background: #4101d5;

  }
  .container2 :nth-child(2) {
    background: #fffc44;
    animation-delay: 0.5s; 
  }
  .container2 :nth-child(3) {
    background: #a439eb;
    animation-delay: 1s; 
  }
  .container2 :last-child {
    background: #cf94f7;
    animation-delay: 1.5s; 
  }

  .container3 div{
    animation-play-state: paused;
  }

  .container3 :first-child {
    background: #4101d5;

  }
  .container3 :nth-child(2) {
    background: #fffc44;
    animation-delay: -0.5s; 
  }
  .container3 :nth-child(3) {
    background: #a439eb;
    animation-delay: -1s; 
  }
  .container3 :last-child {
    background: #cf94f7;
    animation-delay: -1.5s; 
  }

  .btn {
    display: inline-block;
  }
  @keyframes loading {
    0%, 100% {
      transform: translate(0,0)
    }
    25% {
      transform: translate(150%,0)
    }
    50% {
      transform: translate(150%,150%)
    }
    75% {
      transform: translate(0,150%)
    }
  }
</style>

<div class='main-circle'>
  <div class="container-circle">
    <div></div>
    <div></div>
    <div></div>
    <div></div>
  </div>
</div>

<p>假设小球动画时间为 2s，2 / 4 = 0.5，我们让每个小球间隔 0.5s 开始运动就能完成上面的动画。这四个小球按先后运动顺序分别为A B C D。</p>
<p>假设小球的四个标志性的坐标点为 (0, 0) (1, 0) (1, 1) (0, 1)。</p>
<ul>
<li>0.5s 时，A 到达 (1, 0)，B C D 还在 (0, 0);</li>
<li>1s 时，A 到达 (1, 1)，B 到达 (1, 0)，C D 还在 (0, 0);</li>
<li>1.5s 时，A 到达 (0, 1)，B 到达 (1, 1)，C 到达 (1, 0)，D 还在 (0, 0);</li>
<li>2s 时，A 到达 (0, 0)，B 到达 (0, 1)，C 到达 (1, 1)，D 到达 (1, 0);</li>
</ul>
<p>如下所示：</p>
<div class='main-circle'>
  <div class="container-circle container2">
    <div>A</div>
    <div>B</div>
    <div>C</div>
    <div>D</div>
  </div>
  <button class="btn">开始</button>
</div>

<p>在一开始运动时，他们是有一个过渡期的，并不是一开始就看得到四个运动的球。但是如果我们把延迟时间改为负的，那么动画开始前，他们就能到达自己一预定的位置，也就是说相当于并不是延迟，而是提前走了。所以能看到四个小球在他们各自的位置上，如下</p>
<div class='main-circle'>
  <div class="container-circle container3">
    <div>A</div>
    <div>B</div>
    <div>C</div>
    <div>D</div>
  </div>
  <button class="btn">开始</button>
</div>

<script>
  const btn1 = document.getElementsByClassName('btn')[0]
  const btn2 = document.getElementsByClassName('btn')[1]
  const circle1 = document.getElementsByClassName('container2')[0].children;
  const circle2 = document.getElementsByClassName('container3')[0].children;

  btn1.onclick = function() {
    for(let i of circle1) {
      i.style['animation-play-state'] = 'paused';
    }
    console.log(111)
  }

  btn2.onclick = function() {
    console.log(111)
    for(let i of circle2) {
      i.style['animation-play-state'] = 'running';
    }
  }
</script>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS transform 属性</title>
    <url>/2020/07/24/CSS-transform-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<style>
.maxbox {
  background: #F5F3F4;
  margin: 0;
  padding: 10px;
  font-family: 'Open Sans', sans-serif;
  text-align: center;
}

.card {
  display: inline-block;
  margin: 10px;
  background: #fff;
  padding: 15px;
  min-width: 200px;
  box-shadow: 0 3px 5px #ddd;
  color: #555;
}
.card .box {
  width: 100px;
  height: 100px;
  margin: auto;
  background: #ddd;
  cursor: pointer;
  box-shadow: 0 0 5px #ccc inset;
}
.card .box .fill {
  width: 100px;
  height: 100px;
  position: relative;
  background: #03A9F4;
  opacity: .5;
  box-shadow: 0 0 5px #ccc;
  -webkit-transition: 0.3s;
  transition: 0.3s;
  color: #000;
}
.card p {
  margin: 25px 0 0;
}
</style>
<p>transform 的意思是变形，改变。在 CSS 中 transform 属性应用于元素的2D或3D转换。这个属性允许我们将元素旋转（rotate），缩放（scale），移动（translate），倾斜（skew）等，为了更好的理解 transform 属性，我们下面会给出实例。</p>
<a id="more"></a> 
<p>transform 语法: <code>transform: none|transform-functions;</code></p>
<h2 id="transfrom-2D-和-3D-转换"><a href="#transfrom-2D-和-3D-转换" class="headerlink" title="transfrom 2D 和 3D 转换"></a>transfrom 2D 和 3D 转换</h2><p>transform 2D 转换是一个平面的两个轴向上的变形，水平 X 轴，垂直 Y 轴。<br>transform 3D 转换是一个立体的三个轴向上的变形，x轴在电脑屏幕水平向右，y轴在电脑屏幕垂直朝下，z轴垂直电脑屏幕指向你。如下所示：<br><img src="/images/artic/CSS_transform/img-01.jpg" alt="截图"></p>
<h2 id="2D-转换"><a href="#2D-转换" class="headerlink" title="2D 转换"></a>2D 转换</h2><pre><code>| 2D 属性值 | 描述 |
| --- | --- |
| none | 定义不进行转换。|
| rotate(angle) | 定义 2D 旋转，在参数中规定角度。|
| translate(x,y)    | 定义 2D 转换。|
| translateX(x) | 定义转换，只是用 X 轴的值。|
| translateY(y) | 定义转换，只是用 Y 轴的值。|
| scale(x[,y]?) | 定义 2D 缩放转换。|
| scaleX(x) | 通过设置 X 轴的值来定义缩放转换。|
| scaleY(y) | 通过设置 Y 轴的值来定义缩放转换。|
| skew(x_angle,y_angle) | 定义沿着 X 和 Y 轴的 2D 倾斜转换。|
| skewX(angle) | 定义沿着 X 轴的 2D 倾斜转换。|
| skewY(angle) | 定义沿着 Y 轴的 2D 倾斜转换。|
| matrix(n,n,n,n,n,n) | 定义 2D 转换，使用六个值的矩阵。|</code></pre><h4 id="一、-rotate-旋转"><a href="#一、-rotate-旋转" class="headerlink" title="一、 rotate 旋转"></a>一、 rotate 旋转</h4><p>  rotate(angle): 旋转该元素，需要有一个 transform-origin 属性定义旋转的基点，如果不定义则默认是该元素中心，也就是center center。其中旋转角度是正数则表示顺时针旋转，负数则表示逆时针旋转。</p>
<style>
.rotate:hover .fill {
  -webkit-transform: rotate(45deg);
  transform: rotate(45deg);
}
.rotate1:hover .fill {
  -webkit-transform: rotate(-45deg);
  transform: rotate(-45deg);
}
</style>
<div class="maxbox">
  <div class="card">
    <div class="box rotate">
      <div class="fill"></div>
    </div>
    <p>rotate(45deg)  </p>
  </div>
  <div class="card">
    <div class="box rotate1">
      <div class="fill"></div>
    </div>
    <p>rotate(-45deg)  </p>
  </div>
</div>

<h4 id="二、-translate-移动"><a href="#二、-translate-移动" class="headerlink" title="二、 translate 移动"></a>二、 translate 移动</h4><ol>
<li>translate(x,y) 移动<br>translate(x,y): 移动该元素，沿水平方向、垂直方向同时移动。其中一个参数如果未被提供，则以 0 作为其值。也就是translate(x,y) 的 y 值未提供,它表示对象进行平移，按照设定的x,y参数值,当值为负数时，反方向移动物体，其基点默认为元素 中心点，也可以根据transform-origin进行改变基点位置。</li>
</ol>
<style>
.translate:hover .fill {
  -webkit-transform: translate(45px, 45px);
  transform: translate(45px, 45px);
}

.translate1:hover .fill {
  -webkit-transform: translate(-45px, -45px);
  transform: translate(-45px, -45px);
}

.translateX:hover .fill {
  -webkit-transform: translateX(45px);
  transform: translateX(45px);
}

.translateX1:hover .fill {
  -webkit-transform: translateX(-45px);
  transform: translateX(-45px);
}

.translateY:hover .fill {
  -webkit-transform: translateY(45px);
  transform: translateY(45px);
}

.translateY1:hover .fill {
  -webkit-transform: translateY(-45px);
  transform: translateY(-45px);
}
</style>
<div class="maxbox">
  <!-- translate-->
  <div class="card">
    <div class="box translate">
      <div class="fill"></div>
    </div>
    <p>translate(45px, 45px)  </p>
  </div>
  <div class="card">
    <div class="box translate1">
      <div class="fill"></div>
    </div>
    <p>translate(-45px, -45px)  </p>
  </div>
</div>

<ol start="2">
<li>translateX(x) 仅水平移动<br>只向 X 轴进行移动，基点在元素心点，可以通过 transform-origin 改变基点位置，当值为负数时，反方向移动物体。</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box translateX">
      <div class="fill"></div>
    </div>
    <p>translateX(45px)</p>
  </div>
  <div class="card">
    <div class="box translateX1">
      <div class="fill"></div>
    </div>
    <p>translateX(-45px)</p>
  </div>
</div>

<ol start="3">
<li>translateY(y) 仅垂直移动<br>只向 Y 轴进行移动，基点在元素心点，可以通过 transform-origin 改变基点位置，当值为负数时，反方向移动物体。</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box translateY">
      <div class="fill"></div>
    </div>
    <p>translateY(45px)</p>
  </div>
  <div class="card">
    <div class="box translateY1">
      <div class="fill"></div>
    </div>
    <p>translateY(-45px)</p>
  </div>
</div>

<h4 id="三、-scale-缩放"><a href="#三、-scale-缩放" class="headerlink" title="三、 scale 缩放"></a>三、 scale 缩放</h4><ol>
<li>scale(x[,y]?) X轴、Y轴同时缩放<br>scale(x[,y]?): 2D 缩放，基中X表示水平方向缩放的倍数，Y表示垂直方向的缩放倍数，而Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。并以X为准。基点在元素心点，同样也可以通过 transform-origin 改变基点位置。当参数值为负值时，向反方向缩放，例如下面的例子，中间的 scale(-2) 的缩放倍数为 -2，其中的‘正’字就左右翻转，上下翻转后放大了两倍。 右边的 scale(-2) 的缩放倍数为 -2，其中的‘正’字就左右翻转后放大了两倍。</li>
</ol>
<style>
.scale:hover .fill {
  -webkit-transform: scale(2);
  transform: scale(2);
}
.scale1:hover .fill {
  -webkit-transform: scale(-2);
  transform: scale(-2);
}
.scale2:hover .fill {
  -webkit-transform: scale(-2, 2);
  transform: scale(-2, 2);
}

.scaleX:hover .fill {
  -webkit-transform: scaleX(2);
  transform: scaleX(2);
}
.scaleX1:hover .fill {
  -webkit-transform: scaleX(-2);
  transform: scaleX(-2);
}

.scaleY:hover .fill {
  -webkit-transform: scaleY(2);
  transform: scaleY(2);
}
.scaleY1:hover .fill {
  -webkit-transform: scaleY(-2);
  transform: scaleY(-2);
}
</style>
<div class="maxbox">
  <!-- scale-->
  <div class="card">
    <div class="box scale">
      <div class="fill">正</div>
    </div>
    <p>scale(2)</p>
  </div>
  <div class="card">
    <div class="box scale1">
      <div class="fill">正</div>
    </div>
    <p>scale(-2)</p>
  </div>
   <div class="card">
    <div class="box scale2">
      <div class="fill">正</div>
    </div>
    <p>scale(-2，2)</p>
  </div>
</div>

<ol start="2">
<li>scaleX(x) X轴缩放<br>和 scale(x,y) 一样，只是仅支持 X 轴的缩放，基点在元素心点，同样也可以通过 transform-origin 改变基点位置。当参数值为负值时，向反方向缩放，如下面例子中，都是放大 2 倍，但是右边的是负值，‘正’字 X 轴放大 2 倍后左右翻转了。</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box scaleX">
      <div class="fill">正</div>
    </div>
    <p>scaleX(2)    </p>
  </div>
  <div class="card">
    <div class="box scaleX1">
      <div class="fill">正</div>
    </div>
    <p>scaleX(-2)    </p>
  </div>
</div>

<ol start="3">
<li>scaleY(y) Y轴缩放<br>和 scale(x,y) 一样，只是仅支持 Y 轴的缩放，基点在元素心点，同样也可以通过 transform-origin 改变基点位置。当参数值为负值时，向反方向缩放，如下面例子中，都是放大 2 倍，但是右边的是负值，‘正’字 Y 轴放大 2 倍后上下翻转了。</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box scaleY">
      <div class="fill">正</div>
    </div>
    <p>scaleY(-2)    </p>
  </div>
  <div class="card">
    <div class="box scaleY1">
      <div class="fill">正</div>
    </div>
    <p>scaleY(-2)    </p>
  </div>
</div>

<h4 id="四、-skew-扭曲"><a href="#四、-skew-扭曲" class="headerlink" title="四、 skew 扭曲"></a>四、 skew 扭曲</h4><ol>
<li>skew(x,y)<br>skew(x,y): 使元素在水平和垂直方向同时扭曲（X 轴和 Y 轴同时按一定的角度值进行倾斜变形），同样是以元素中心为基点，我们也可以通过 transform-origin 来改变元素的基点位置。</li>
</ol>
<style>
.skew:hover .fill {
  -webkit-transform: skew(45deg, 45deg);
  transform: skew(45deg, 45deg);
}
.skew1:hover .fill {
  -webkit-transform: skew(-45deg, -45deg);
  transform: skew(-45deg, -45deg);
}

.skewX:hover .fill {
  -webkit-transform: skewX(45deg);
  transform: skewX(45deg);
}
.skewX1:hover .fill {
  -webkit-transform: skewX(-45deg);
  transform: skewX(-45deg);
}

.skewY:hover .fill {
  -webkit-transform: skewY(45deg);
  transform: skewY(45deg);
}
.skewY1:hover .fill {
  -webkit-transform: skewY(-45deg);
  transform: skewY(-45deg);
}
</style>
<div class="maxbox">
  <div class="card">
    <div class="box skew">
      <div class="fill"></div>
    </div>
    <p>skew(45deg, 45deg)  </p>
  </div>
  <div class="card">
    <div class="box skew1">
      <div class="fill"></div>
    </div>
    <p>skew(-45deg, -45deg)  </p>
  </div>
</div>

<ol start="2">
<li>skewX(angle)<br>skewX(angle): 仅使元素在水平方向扭曲变形（X轴倾斜变形），同样可以通过transform-origin来改变元素的基点位置，默认基点为中心。</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box skewX">
      <div class="fill"></div>
    </div>
    <p>skewX(45deg)</p>
  </div>
  <div class="card">
    <div class="box skewX1">
      <div class="fill"></div>
    </div>
    <p>skewX(-45deg)</p>
  </div>
</div>

<ol start="3">
<li>skewY(angle)<br>skewY(angle): 仅使元素在垂直方向扭曲变形（Y 轴倾斜变形），同样可以通过 transform-origin 来改变元素的基点位置，默认基点为中心。</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box skewY">
      <div class="fill"></div>
    </div>
    <p>skewY(45deg)</p>
  </div>
  <div class="card">
    <div class="box skewY1">
      <div class="fill"></div>
    </div>
    <p>skewY(-45deg)</p>
  </div>
</div>

<h4 id="五、-matrix-矩阵"><a href="#五、-matrix-矩阵" class="headerlink" title="五、 matrix 矩阵"></a>五、 matrix 矩阵</h4><p>  matrix(a,b,c,d,e,f) 比较复杂，包含了 rotate translate scale skew，是图形变化的原理，先不做讨论。</p>
<h3 id="3D-转换"><a href="#3D-转换" class="headerlink" title="3D 转换"></a>3D 转换</h3><pre><code>| 3D 属性值 | 描述 |
| --- | --- |
| rotate3d(x,y,z,angle) | 定义 3D 旋转。|
| rotateX(angle) | 定义沿着 X 轴的 3D 旋转。|
| rotateY(angle) | 定义沿着 Y 轴的 3D 旋转。|
| rotateZ(angle) | 定义沿着 Z 轴的 3D 旋转。|
| translate3d(x,y,z)    | 定义 3D 转换。|
| translateZ(z) | 定义 3D 转换，只是用 Z 轴的值。|
| scale3d(x,y,z) | 定义 3D 缩放转换。|
| scaleZ(z) | 通过设置 Z 轴的值来定义 3D 缩放转换。|
| matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) | 定义 3D 转换，使用 16 个值的 4x4 矩阵。
| perspective(n) | 为 3D 转换元素定义透视视图。|</code></pre><h4 id="rotate-3D旋转"><a href="#rotate-3D旋转" class="headerlink" title="rotate 3D旋转"></a>rotate 3D旋转</h4><ol>
<li>rotate3d(x, y, z, angle)<br>rotate3d(x, y, z, angle): 定义3D旋转。X 轴、Y 轴、Z 轴方向上的旋转<br>x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值；<br>y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值；<br>z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值；<br>angle：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值表示元素顺时针旋转，为负值表示元素逆时针旋转。</li>
</ol>
<style>
.rotate3d:hover .fill {
  -webkit-transform: rotate3d(1, 1, 1, 45deg);
  transform: rotate3d(1, 1, 1, 45deg);
}
.rotate3d1:hover .fill {
  -webkit-transform: rotate3d(1, 1, 1, -45deg);
  transform: rotate3d(1, 1, 1, -45deg);
}

.rotateX:hover .fill {
  -webkit-transform: rotateX(45deg);
  transform: rotateX(45deg);
}
.rotateX1:hover .fill {
  -webkit-transform: rotateX(-45deg);
  transform: rotateX(-45deg);
}

.rotateY:hover .fill {
  -webkit-transform: rotateY(45deg);
  transform: rotateY(45deg);
}
.rotateY1:hover .fill {
  -webkit-transform: rotateY(-45deg);
  transform: rotateY(-45deg);
}

.rotateZ:hover .fill {
  -webkit-transform: rotate(45deg);
  transform: rotate(45deg);
}
.rotateZ1:hover .fill {
  -webkit-transform: rotate(-45deg);
  transform: rotate(-45deg);
}
</style>

<div class="maxbox">
  <div class="card">
    <div class="box rotate3d">
      <div class="fill">正</div>
    </div>
    <p>rotate3d(1, 1, 1, 45deg)</p>
  </div>
  <div class="card">
    <div class="box rotate3d1">
      <div class="fill">正</div>
    </div>
    <p>rotate3d(1, 1, 1, -45deg)</p>
  </div>
</div>

<ol start="2">
<li>rotateX(angle)<br>rotateX(angle): 定义沿着 X 轴的 3D 旋转，正值顺时针，负值逆时针，旋转基点默认为中心，同样也用 transform-origin 可以改变。<br>rotateX(angle) 等价于 rotate3d(1,0,0,angle)</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box rotateX">
      <div class="fill"></div>
    </div>
    <p>rotateX(45deg)</p>
  </div>
  <div class="card">
    <div class="box rotateX1">
      <div class="fill"></div>
    </div>
    <p>rotateX(-45deg)</p>
  </div>
</div>

<ol start="3">
<li>rotateY(angle)<br>rotateY(angle): 定义沿着 Y 轴的 3D 旋转，正值顺时针，负值逆时针，旋转基点默认为中心，同样也用 transform-origin 可以改变。<br>rotateY(angle) 等价于 rotate3d(0,1,0,angle)</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box rotateY">
      <div class="fill"></div>
    </div>
    <p>rotateY(45deg)</p>
  </div>
  <div class="card">
    <div class="box rotateY1">
      <div class="fill"></div>
    </div>
    <p>rotateY(-45deg)</p>
  </div>
</div>

<ol start="4">
<li>rotateZ(angle)<br>rotateZ(angle): 定义沿着 Z 轴的 3D 旋转，正值顺时针，负值逆时针，旋转基点默认为中心，同样也用 transform-origin 可以改变。<br>rotateZ(angle) 等价于 rotate3d(0,0,1,angle)</li>
</ol>
<div class="maxbox">
  <div class="card">
    <div class="box rotateZ">
      <div class="fill"></div>
    </div>
    <p>rotateZ(45deg)  </p>
  </div>
  <div class="card">
    <div class="box rotateZ1">
      <div class="fill"></div>
    </div>
    <p>rotateZ(-45deg)  </p>
  </div>
</div>

<h4 id="translate-3D-移动"><a href="#translate-3D-移动" class="headerlink" title="translate 3D 移动"></a>translate 3D 移动</h4><ol>
<li>translate3d(x,y,z)<br>translate3d(x,y,z): 定义3D平移，x,y,z分别为移动的位移量，如果设置 z 值为 0 ，则就是在 X Y 平面的移动。和 translate(x, y) 一样。在使用 translate3d 和 translateZ 时必须要先定义 perspective 值，否则没有效果，z 值是 Z 轴上的位移，近大远小。</li>
</ol>
<style>
.percard {
  perspective: 1000px;
}
.translate3d:hover .fill {
  -webkit-transform: translate3d(45px, 45px, 0);
  transform: translate3d(45px, 45px, 0);
}
.translate3d1:hover .fill {
  -webkit-transform: translate3d(45px, 45px, 45px);
  transform: translate3d(45px, 45px, -1000px);
}

.translateZ:hover .fill {
  -webkit-transform: translateZ(45px);
  transform: translateZ(45px);
}
.translateZ1:hover .fill {
  -webkit-transform: translateZ(900px);
  transform: translateZ(900px);
}
</style>

<div class="maxbox">
  <div class="card">
    <div class="box translate3d">
      <div class="fill"></div>
    </div>
    <p>translate3d(45px,45px)  </p>
  </div>
  <div class="card percard">
    <div class="box translate3d1">
      <div class="fill"></div>
    </div>
    <p>translate3d(45px,45px,45px)  </p>
  </div>
</div>

<ol start="2">
<li>translateZ(z)<br>translateZ(z): 在 Z 轴上的位移量，具体表现就是让元素在自己的眼前或近或远，近大远小，当 z 值接近于 perspective 值时，件相当于贴近眼前，该元素的大小会撑满整个屏幕。当 z 值大于 perspective 值时，就会看不到该元素，相当于跑到我们眼睛后面去了，所以看不到了。</li>
</ol>
<div class="maxbox">
  <div class="card percard">
    <div class="box translateZ">
      <div class="fill"></div>
    </div>
    <p>translateZ(45px)  </p>
  </div>
  <div class="card percard">
    <div class="box translateZ1">
      <div class="fill"></div>
    </div>
    <p>translateZ(900px)  </p>
  </div>
</div>

<h4 id="scale-3D-缩放"><a href="#scale-3D-缩放" class="headerlink" title="scale 3D 缩放"></a>scale 3D 缩放</h4><ol>
<li><p>scale3d(x,y,z): 通过使用3D缩放函数，可以让元素在Z轴上按比例缩放。默认值为1，当值大于1时，元素放大，反之小于1大于0.01时，元素缩小。</p>
</li>
<li><p>scaleZ(z): 通过设置Z轴的值来定义缩放转换。scaleZ() 和 scale3d() 函数 的 z 值单独使用时没有任何效果，需要配合其他的变形函数一起使用才会有效果。 </p>
<p>如下，左和中效果一样，中间虽然设置 scale3d(x,y,z) 的 z 为 4，但是看不出差别，右边的更加是没什么变化。</p>
</li>
</ol>
<style>
.scale3d:hover .fill{
  -webkit-transform: scale3d(2,2,1);
  transform: scale3d(2,2,1);
}
.scale3d1:hover .fill{
  -webkit-transform: scale3d(2,2,4);
  transform: scale3d(2,2,4);
}
.scaleZ:hover .fill{
  -webkit-transform: scaleZ(4);
  transform: scaleZ(4);
}
</style>
<div class="maxbox">
  <div class="card">
    <div class="box scale3d">
      <div class="fill"></div>
    </div>
    <p>scale3d(2,2,1)  </p>
  </div>
  <div class="card percard">
    <div class="box scale3d1">
      <div class="fill"></div>
    </div>
    <p>scale3d(2,2,4)  </p>
  </div>
  <div class="card percard">
    <div class="box scaleZ">
      <div class="fill"></div>
    </div>
    <p>scaleZ(4)  </p>
  </div>
</div>


<h3 id="Perspective"><a href="#Perspective" class="headerlink" title="Perspective"></a>Perspective</h3><p>perspective 是视距，写在父元素上，表示从何处查看一个元素。在 CSS3 中的 3D 场景中所有元素都是放置在 z=0 的平面上。比如 perspective(300px) 表示: 镜头距离元素表面的位置是 300 像素。</p>
<style>
.perspective-100 .box {
  -webkit-perspective: 100px;
  perspective: 100px;
}

.perspective-200 .box {
  -webkit-perspective: 200px;
  perspective: 200px;
}
</style>

<ol>
<li>Perspective : 100<br>下面左边的例子有 perspective 属性，元素盒子在中心沿 X 轴顺时针旋转 70 度，导致上半部分离我们设定的视距远，下半部分离我们的视距近，近大远小，更有立体感。<br>右边的例子就没有这种立体感了。</li>
</ol>
<style>
.rotateXp:hover .fill{
  -webkit-transform: rotateX(70deg);
  transform: rotateX(70deg);
}
</style>

<div class="maxbox">
  <div class="card perspective-100">
    <div class="box rotateXp">
      <div class="fill"></div>
    </div>
    <p>perspective-100 rotateX(70deg)</p>
  </div>
  <div class="card">
    <div class="box rotateXp">
      <div class="fill"></div>
    </div>
    <p>rotateX(70deg)</p>
  </div>
</div>

<ol start="2">
<li>Perspective : 200<br>perspective 为 200px 时，视距比 100px 大，元素盒子旋转之后同上。但是由于视距增加了，所以看起来比 perspective 为 100px 时小。</li>
</ol>
<div class="maxbox">
  <div class="card perspective-200">
    <div class="box rotateXp">
      <div class="fill"></div>
    </div>
    <p>perspective-200 rotateX(70deg)</p>
  </div>
  <div class="card">
    <div class="box rotateXp">
      <div class="fill"></div>
    </div>
    <p>rotateX(70deg)</p>
  </div>
</div>


<h3 id="Transform-origin-改变元素基点"><a href="#Transform-origin-改变元素基点" class="headerlink" title="Transform-origin 改变元素基点"></a>Transform-origin 改变元素基点</h3><p>终于到了前面多次提到改变基点位置的 transform-origin() 属性，之前说过 transform-origin 属性可以改变元素的基点位置，在没有设置 transform-origin 属性时，元素的基点都是元素的中心位置，不管是旋转、移动、缩放、扭曲都是以元素中心位置进行变形。有时候，我们要在不同的位置进行变形，这时候就要用到 transform-origin 属性改变基点位置。<br>transform-origin(x,y,z) 语法: <code>transform-origin: x-axis y-axis z-axis;</code>   </p>
<ol>
<li>x-axis: 设置基点在 X 轴的何处，相应的值为 left center right length %</li>
<li>y-axis: 设置基点在 Y 轴的何处，相应的值为 left center right length %</li>
<li>z-axis: 设置基点在 Z 轴的何处，相应的值为 length %</li>
</ol>
<p>例如:</p>
<ul>
<li>transform-origin: 100% 0 0; 表示设置基点为元素的右顶点;</li>
<li>transform-origin: 0 0 0; 表示设置基点为元素的左顶点;</li>
<li>transform-origin: 100% 100% 0; 表示设置基点为元素的右下角顶点;</li>
<li>transform-origin: 0 100% 0; 表示设置基点为元素的左下角顶点;</li>
</ul>
<style>
.to-100-0-0 {
  -webkit-transform-origin: 100% 0 0;
  transform-origin: 100% 0 0;
}

.to-0-0-0 {
  -webkit-transform-origin: 0 0 0;
  transform-origin: 0 0 0;
}

.to-100-100-0 {
  -webkit-transform-origin: 100% 100% 0;
  transform-origin: 100% 100% 0;
}

.to-0-100-0 {
  -webkit-transform-origin: 0 100% 0;
  transform-origin: 0 100% 0;
}
</style>
<div class="maxbox">
  <div class="card">
    <div class="box rotate">
      <div class="fill to-100-0-0"></div>
    </div>
    <p>transform-origin : 100% 0 0  <br/>rotate(45deg)</p>
  </div>
  <div class="card">
    <div class="box rotate">
      <div class="fill to-0-0-0"></div>
    </div>
    <p>transform-origin : 0 0 0  <br/>rotate(45deg)</p>
  </div>
  <div class="card">
    <div class="box rotate">
      <div class="fill to-100-100-0"></div>
    </div>
    <p>transform-origin : 100% 100% 0  <br/>rotate(45deg)</p>
  </div>
  <div class="card">
    <div class="box rotate">
      <div class="fill to-0-100-0"></div>
    </div>
    <p>transform-origin : 0 100% 0  <br/>rotate(45deg)</p>
  </div>
</div>

<p>一般 perspective 都是和 origin 合起来使用，增强元素的立体感。<br>例如下面的 Y 轴方向的旋转:<br>左边的没改变旋转的基点，中间的改变了元素的旋转基点但是没有添加视距 perspective，右边的既改变了旋转基点，又添加了视距 perspective。前面的两个根本看不出来是 3D 的旋转，最后一个却看得出来是绕右边框旋转，增强了立体感。</p>
<div class="maxbox">
  <div class="card">
    <div class="box rotateY">
      <div class="fill"></div>
    </div>
    <p>没改变基点 <br/>rotateY(45deg)</p>
  </div>
  <div class="card">
    <div class="box rotateY">
      <div class="fill to-100-0-0"></div>
    </div>
    <p>transform-origin : 0 100% 0  <br/>rotateY(45deg)</p>
  </div>
  <div class="card perspective-200">
    <div class="box rotateY">
      <div class="fill to-100-0-0"></div>
    </div>
    <p>transform-origin : 0 100% 0  <br/>rotateY(45deg)</p>
  </div>
</div>

<p>具体的 matrix() 属性等以后弄清楚了在详细介绍，扭曲(skew)、Z 轴上的缩放(scaleZ()) 以及 perspective 视距和 transform-origin 怎么样配合才能更立体也需要一定的想象力，要想写好页面的一些特效，熟练的了解 transform 属性是必须的，加油！</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS transition 属性</title>
    <url>/2020/07/21/CSS-transition-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition 过渡"></a>transition 过渡</h3><p>transition 属性是一个简写属性，用于设置四个过渡属性。<br>四个过渡属性为：</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">transition-property</td>
<td align="center">指定过渡的 CSS 属性，默认值 all</td>
</tr>
<tr>
<td align="center">transition-duration</td>
<td align="center">完成过度效果需要时间，默认值 0</td>
</tr>
<tr>
<td align="center">transition-timing-function</td>
<td align="center">指定过渡的转速曲线，默认值 ease</td>
</tr>
<tr>
<td align="center">transition-delay</td>
<td align="center">指定过渡的delay，默认值 0</td>
</tr>
</tbody></table>
<p>transition 定义了动画的属性、时间、速度曲线和延迟时间，通常和hover事件配合使用，由事件触发。</p>
<p>例如，一个100x100px 的 div，在 hover 时 width 变为 500px。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.test</span>&#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    transition-duration: 3s; </span><br><span class="line">    transition-property: all;</span><br><span class="line">    transition-timing-function: ease;</span><br><span class="line">    transition-delay: 0s;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="css"><span class="selector-class">.test</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>鼠标移动到 div 元素上，这个正方形会渐变为 500x100 的长方形</p>
<style>
.test{
    height: 100px;
    width: 100px;
    background-color: pink;
    transition-duration: 3s;
    transition-property: all;
    transition-timing-function: ease;
    transition-delay: 0s;
}    
.test:hover{
    width: 500px;
}
</style>
<div class="test"></div>

<p>transition 的 duration（过渡时间）属性值为 0 时不会产生任何效果，所以我们使用 transition 时必须要给这个属性值赋值。其他的三个值可以不赋值，一般我们都是使用 transition 属性，不会分开写它的四个属性值。由于四个子属性中，duration（过渡时间） 和 delay（延迟时间）都是时间，当出现两个时间时，第一个为 duration（过渡时间），第二个为 delay（延迟时间）。<br>默认语法顺序为<code>transition: property duration timing-function delay;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.test</span>&#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    transition: 3s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.test</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果一样</p>
<style>
.test{
    height: 100px;
    width: 100px;
    background-color: pink;
    transition: 3s;
}
.test:hover{
    width: 500px;
}
</style>
<div class="test"></div>

<p>此外 transition 还可以使用逗号隔开来表示不同的属性，例如 test1 的 width 和 background 默认同时过渡，而 test2 的 width 和 background 我们通过逗号隔开，使其过渡效果不同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.test1</span> &#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    transition: 2s linear 200ms;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.test2</span> &#123;</span></span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    transition: width 2s linear 200ms, background 1s linear 200ms;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line">  display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.test1</span>,<span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.test2</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test2"</span>&gt;</span>test2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>test1 的 width 和 background 的过渡时间一样，而 test2 的 background 比 width 先完成过渡，可以看到test2 还在变长时背景就已经全黑了，对比与 test1 特别明显。</p>
<style>
.test1 {
    height: 100px;
    width: 100px;
    background-color: pink;
    transition: 2s linear 200ms;
}
.test2 {
    height: 100px;
    width: 100px;
    background-color: pink;
    transition: width 2s linear 200ms, background 1s linear;
}
.box {
  display: inline-block;
}
.box:hover .test1,.box:hover .test2 {
    width: 500px;
    background: #000;
}
</style>
<div class="box">
  <div class="test1">test1</div>
  <div class="test2">test2</div>
</div>

<h3 id="transition-的-transition-timing-function-子属性"><a href="#transition-的-transition-timing-function-子属性" class="headerlink" title="transition 的 transition-timing-function 子属性"></a>transition 的 transition-timing-function 子属性</h3><p>transition-timing-function 子属性用于指定过渡效果的速度。过渡时间函数有六种值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>linear</td>
<td>规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</td>
</tr>
<tr>
<td>ease</td>
<td>规定慢速开始，然后变快，然后慢速结束的过渡效果</td>
</tr>
<tr>
<td>ease-in</td>
<td>规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</td>
</tr>
<tr>
<td>ease-out</td>
<td>规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</td>
</tr>
<tr>
<td>cubic-bezier(n,n,n,n)</td>
<td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td>
</tr>
</tbody></table>
<p>具体效果如下：<br>linear 匀速</p>
<style>
.box1{
    height: 100px;
    width: 100px;
    background-color: pink;
    transition: 3s linear;
}
.box1:hover{
    width: 800px;
}
</style>
<div class="box1"></div>

<p>ease 慢-快-慢</p>
<style>
.box2{
    height: 100px;
    width: 100px;
    background-color: pink;
    transition: 3s ease;
}
.box2:hover{
    width: 800px;
}
</style>
<div class="box2"></div>

<p>ease-in 慢-快</p>
<style>
.box3{
    height: 100px;
    width: 100px;
    background-color: pink;
    transition: 3s ease-in;
}
.box3:hover{
    width: 800px;
}
</style>
<div class="box3"></div>

<p>ease-out 快-慢</p>
<style>
.box4{
    height: 100px;
    width: 100px;
    background-color: pink;
    transition: 3s ease-out;
}
.box4:hover{
    width: 800px;
}
</style>
<div class="box4"></div>

<p>ease-in-out 慢开始慢结束</p>
<style>
.box5{
    height: 100px;
    width: 100px;
    background-color: pink;
    transition: 3s ease-in-out;
}
.box5:hover{
    width: 800px;
}
</style>
<div class="box5"></div>

<p>其他具体的进一步了解了再记录，加油！</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器和可迭代对象</title>
    <url>/2020/07/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="迭代器-遍历器"><a href="#迭代器-遍历器" class="headerlink" title="迭代器(遍历器)"></a>迭代器(遍历器)</h2><p>迭代器（Iterator）是一种接口，也可以说是一种机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。  </p>
<a id="more"></a>
<p>迭代器的作用：</p>
<ol>
<li>为各种数据结构提供一种一个统一的、简单的访问接口；</li>
<li>是数据结构的成员能够按某种序列排序；</li>
<li>ES6 有一种新的遍历命令 <code>for...of</code> 循环，Iterator 主要提供给 <code>for...of</code> 使用。</li>
</ol>
<p>迭代器的遍历过程：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li>
</ol>
<p>迭代器是通过使用 next() 方法实现的，该方法一个拥有 value 属性和 done 属性的对象，value，是序列中的 next 值；done ，如果已经迭代到序列中的最后一个值，则它为 true，否则为 false。每次调用 next() 方法，都会返回数据结构中的当前值，也就是 {value, done} 这个对象，其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。<br>例如我们获取一个可迭代对象的迭代器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;<span class="attr">num</span>:<span class="number">1</span>&#125;,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]() <span class="comment">// 获取数组中的迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())     <span class="comment">// &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())     <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())     <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next())     <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是可迭代对象"><a href="#什么是可迭代对象" class="headerlink" title="什么是可迭代对象"></a>什么是可迭代对象</h2><p>若一个对象拥有迭代行为，比如在 <code>fpr...of</code> 中会循环对象的值，那么这个对象就是可迭代对象，在 JS 中可迭代对象有：</p>
<ol>
<li>Array</li>
<li>String</li>
<li>Set</li>
<li>Map</li>
<li>arguments（类数组对象）</li>
<li>NodeList（DOM 节点集合）</li>
</ol>
<p>一个数据是否可迭代要看它是否具有 Iterator 接口，所以我们可以看这个对象（或其原型链上）是否具有 Symbol.iterator 属性。<br>例如打印一个数组的信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.hasOwnProperty(<span class="built_in">Symbol</span>.iterator)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Set</span>.prototype.hasOwnProperty(<span class="built_in">Symbol</span>.iterator));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>我们把一个字符串的 Symbol.iterator 属性改为 null，看是否还能使用 <code>for...of</code> 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abcdefg'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// a b c d e f g</span></span><br><span class="line">&#125;</span><br><span class="line">str.__proto__[<span class="built_in">Symbol</span>.iterator] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 报错 str is not iterable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到当我们改变了一个可迭代对象的 Symbol.iterator 属性后，它就变成不可迭代对象了。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是闭包</title>
    <url>/2020/07/17/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>《JavaScript高级程序设计》里面说：</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数,创建闭包的常见方式就是在一个函数内部创建另一个函数</p>
</blockquote>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sex = <span class="string">"男"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(sex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = Func();</span><br><span class="line"></span><br><span class="line">func(); <span class="comment">// 男</span></span><br><span class="line"><span class="built_in">console</span>.log(sex);  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中, Func 函数执行返回了一个函数赋值给了变量 func。Func 函数在执行完后会被销毁，其内部的变量 sex 也随之一起销毁了，在作用域外应该是访问不到 sex 变量的，我们直接在外层作用域输出 sex 也确实报错了。但是我们执行 func 函数的时候却成功的输出了变量 sex 的值。<br>因为，JavaScript 中的函数会形成闭包，闭包是由函数以及声明该函数的语法环境组合而成的，该环境包含了创建这个闭包时的作用域内的所有局部变量。也就是例子中 Func 内部的所有变量。外部作用于是不能访问它的内层作用域的，在不同的函数作用域中也不能互相访问，但是我们可以通过闭包做到这一点。就如上面的例子中，我们通过闭包在全局作用域中访问到了一个函数作用域内的变量 sex。</p>
<h4 id="闭包的-3-个条件"><a href="#闭包的-3-个条件" class="headerlink" title="闭包的 3 个条件"></a>闭包的 3 个条件</h4><ol>
<li>函数必须有一个内嵌函数;</li>
<li>内嵌函数必须引用外层函数中的变量;</li>
<li>外层函数的返回值必须是内嵌函数</li>
</ol>
<h3 id="闭包相关的题目"><a href="#闭包相关的题目" class="headerlink" title="闭包相关的题目"></a>闭包相关的题目</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 3</span></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 3</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>当 data[0] 函数执行的时候，函数内部作用域没有 变量 i，就像外层作用域查找，此时外层作用域是全局作用域，变量 i 的值为 3 (如例子中打印的)，所以输出 3，data[1]、data[2]同理。<br>使用闭包保存变量 i，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 3</span></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>每次循环时，外层匿名函数都会保存传进来的实参，而当 data[0] 函数执行的时候，data[0]函数作用域内部没有变量 i，此时的外层作用域是匿名函数，变量 i 的值为循环时传进来的实参 0 1 2 ，data[0]函数的 i = 0，所以打印结果为 0。data[1] 和 data[2] 同理。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 原型和原型链</title>
    <url>/2020/07/16/JavaScript-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>我们创建的每一个 JavaScript 对象都有一个 prototype (原型) 属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以有特定类型的所有实例共享的属性和方法。以为就是说 prototype 指向一个通过调用构造函数而创建的实例对象的原型对象，使用原型对象的好处是可以让所有实例共享它所包含的属性和方法。也就是说，我们不必在构造函数中定义对象实例的信息，而是将这些信息添加到原型对象中，例如：</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'张三'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">//张三</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.age);  <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>构造函数与实例原型的关系<br><img src="/images/artic/js_prototype/img01.jpg" alt="截图"></p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>这是每个 JavaScript 对象(除了 null) 都有的一个属性, <code>__proto__</code>，这个属性指向该对象的原型。<br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>实例与实例原型的关系<br><img src="/images/artic/js_prototype/img02.jpg" alt="截图"></p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>实例和构造函数都有指向原型的属性，原型虽然没有指向实例的的属性，但是有指向构造函数的属性: constructor，每个原型都有一个指向构造函数的属性。另外我们可以通过 instanceof 关键字 判断它左边的对象是否是它右边的类的实例。<br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>实例原型与构造函数关系<br><img src="/images/artic/js_prototype/img03.jpg" alt="截图"></p>
<h3 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h3><p>构造函数、实例原型和实例的关系我们了解了，name实例和实例原型的关系呢？<br>当读取实例的属性时，如果找不到，就会查找该实例的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'张三'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 李四</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sex) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们给实例对象 person 添加了 name 属性，打印为我们添加的 张三<br>但是我们后来删除了这个实例的 name 属性，我们再获取 name 属性时，吗，明明在实例里找不到该属性，我们还是输出了 李四，因为我们从实例对象 person 中招不到 name 属性，就会到它的原型中找，原型中有 name 属性，所以返回了该属性的值，而我们在原型和原型的原型上也没有找到 sex 属性，所以返回了 undefined。 </p>
<h3 id="原型与原型"><a href="#原型与原型" class="headerlink" title="原型与原型"></a>原型与原型</h3><p>上面的 person.sex 返回的是 undefined，是在原型和原型的原型上查到，一直找到顶端没找到而返回的结果，那么原型的原型和原型的顶端又是什么呢？<br>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Kyle'</span>;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__)</span><br></pre></td></tr></table></figure>
<p><img src="/images/artic/js_prototype/img04.jpg" alt="截图"></p>
<p>我们可以看到 person 的原型是构造函数Person 的 Person.prototype，Person.prototype 的 <code>__proto__</code> 指向了Object.prototype，而 Object.prototype 只有 constructor 属性，没有看到 <code>__proto__</code> 属性，也就是 Object.prototype 是原型的顶层。<br>这一点我们可以通过对象的创建方式知道，<code>let obj = new Object()</code>，原型对象也是通过 Object 构造函数创建的，我们可以看到 Object.constructor 指向的是 Object 构造函数。<br>即原型与原型的关系:<br><img src="/images/artic/js_prototype/img05.jpg" alt="截图"></p>
<p>那么 Object.prototype 的 <code>__proto__</code> 属性呢，我们可有打印：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>所以我们可以说 Object.prototype 没有原型，即 Object.prototype 是原型的顶层，查找属性查到 Object.prototype 就停止查找了，这一路的原型、原型的原型组成的链状结构称为原型链<br>原型链示意图:<br><img src="/images/artic/js_prototype/img06.jpg" alt="截图"></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>call() apply()和 bind() 的区别</title>
    <url>/2020/07/15/JS%20%E4%B8%AD%20call()%E3%80%81apply()%E5%92%8C%20bind()%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="JavaScript-call-方法"><a href="#JavaScript-call-方法" class="headerlink" title="JavaScript call() 方法"></a>JavaScript call() 方法</h3><p>  call() 方法是预定义的 JavaScript 方法。它可以用来调用所有者对象作为参数的方法。通过 call()，您能够使用属于另一个对象的方法。<br>  例如调用 person 的 getNAme 方法。并用于person1</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"李四"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName.call(person1));  <span class="comment">//返回 '李四'</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-apply-方法"><a href="#JavaScript-apply-方法" class="headerlink" title="JavaScript apply() 方法"></a>JavaScript apply() 方法</h3><p>  apply() 方法和 call() 方法非常相似也是可以改变一个函数的 this 的指向<br>  例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"李四"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName.apply(person1));  <span class="comment">//返回 '李四'</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-bind-方法"><a href="#JavaScript-bind-方法" class="headerlink" title="JavaScript bind() 方法"></a>JavaScript bind() 方法</h3><p>  bind() 方法创建一个新函数，this将其关键字设置为调用该函数时传递的第一个值。所有其他参数前面都有调用该函数时传递的值。<br>  例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">"李四"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName.bind(person1));  <span class="comment">//返回一个函数</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName.bind(person1)()); <span class="comment">// 返回 '李四'</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-call-apply-和-bind-方法的区别"><a href="#JavaScript-call-apply-和-bind-方法的区别" class="headerlink" title="JavaScript call() apply()和 bind() 方法的区别"></a>JavaScript call() apply()和 bind() 方法的区别</h3><ol>
<li><p>call() 和 apply() 方法的相同点</p>
<ul>
<li>方法的功能是一样的</li>
<li>第一个参数都是一个对象或函数</li>
</ul>
</li>
<li><p>call() 和 apply() 方法的不同点</p>
<ul>
<li>call() 可以传入多个参数</li>
<li>apply() 只能传入两个参数，第二个参数要以数组的形式传入,否则会报错</li>
</ul>
</li>
<li><p>bind() 返回的是一个新的函数，它的第一个参数和call()、apply() 一样，也和 call() 一样可以传入多个参数</p>
</li>
</ol>
<p>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">"李四"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getName.call(person1, <span class="string">'call'</span>, <span class="string">'call'</span>)); <span class="comment">//输出 'call','call'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getName.apply(person1, [<span class="string">'apply'</span>, <span class="string">'apply'</span>])); <span class="comment">//输出 'apply','apply'</span></span><br><span class="line">person.getName.apply(person1, <span class="string">'apply'</span>, <span class="string">'apply'</span>); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getName.bind(person1, <span class="string">'bind'</span>, <span class="string">'bind'</span>)()); <span class="comment">//输出 'bind','bind'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName.bind(person1, <span class="string">'bind'</span>, <span class="string">'bind'</span>); <span class="comment">//输出 getName 函数</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝</title>
    <url>/2020/07/14/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<ul>
<li><strong>浅拷贝:</strong>  创建一个新对象，对象的属性复制自被拷贝的对象，且只复制一层被拷贝对象的属性。如果被拷贝对象的属性是基础类型的，就复制基础类型的值，如果是引用类型，则复制的是引用类型的内存地址，当改变被拷贝的对象里面的引用类型属性时，拷贝的新对象的属性值也会改变，因为它们都是指向同一个内存地址。<a id="more"></a></li>
<li><strong>深拷贝:</strong>  重新开辟一个新的内存空间，若被拷贝对象的引用类型的值还是引用类型，则可能需要用到递归，直到完全的复制一个对象，新对象和被拷贝的对象看起来一样，但对应的是不同的内存地址，彼此之间互不影响。</li>
</ul>
<h3 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h3><ol>
<li><p>基本类型:<br>Undefined、Null、Boolean、String、Number、BigInt、Symbol，基本数据类型直接存放在栈内存中，可以直接访问</p>
</li>
<li><p>引用类型:<br>Object， 里面包含 function、array、Date，引用类型存放在堆内存中，变量保存的是一个指向该内存地址的指针，当访问引用类型时，先从占栈内存中获取给对象的地址指针，然后再在堆内存中获取该引用类型的数据</p>
</li>
</ol>
<h3 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h3><ol>
<li><p>简单的循环复制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">//判断拷贝的是数组还是对象，是数组建一个空数组，否则建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> result = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    result[key] = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = &#123;<span class="attr">a</span>:<span class="string">'aa'</span>, <span class="attr">b</span>:<span class="string">'bb'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(clone(arr)) <span class="comment">//&#123;a: "aa", b: "bb"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.assign() 方法<br>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。<br>拷贝数组或对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(result, obj)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">54</span>]</span><br><span class="line"><span class="built_in">console</span>.log(clone(arr)) <span class="comment">//[1, 2, 3, 4, 4, 54]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拓展运算符 …</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [...obj] : &#123;...obj&#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">54</span>]</span><br><span class="line"><span class="built_in">console</span>.log(clone(arr)) <span class="comment">//[1, 2, 3, 4, 4, 54]</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h3><p>简单的深拷贝，数组和对象,在拷贝的时候判断一下属性值的类型，如果是对象，我们就递归调用深拷贝函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> copy = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ? copy(obj[key]) : obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">"kyle"</span>,</span><br><span class="line">    flag: &#123;</span><br><span class="line">        title: <span class="string">"Study every day"</span>,</span><br><span class="line">        time: <span class="string">"2020-7-14"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = copy(a);</span><br><span class="line">a.flag.title = <span class="string">'aaaa'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.flag.title) <span class="comment">// aaaa</span></span><br><span class="line"><span class="built_in">console</span>.log(b.flag.title) <span class="comment">// Study every day</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用vue制作扫雷游戏</title>
    <url>/2020/04/03/%E5%88%A9%E7%94%A8vue%E5%88%B6%E4%BD%9C%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="扫雷小游戏"><a href="#扫雷小游戏" class="headerlink" title="扫雷小游戏"></a>扫雷小游戏</h2><h3 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h3><ol>
<li>有简单、一般、困难和自定义四种模式，根据点击模式按钮选择模式;</li>
<li>根据不同模式生成不同大小和雷数的雷区;</li>
<li>有计时和计数功能;</li>
<li>游戏失败和成功时有相应的提示;</li>
<li>有游戏重置功能;</li>
<li>左键点击触发当前格子，右键点击标记当前格子或取消已标记的格子;</li>
<li>已标记的格子不能被触发，且当标记数达到雷的数量时不能再添加新的标记。</li>
<li>左键点击到雷时游戏失败结束游戏，显示所有标记正确和标记错误的以及没标记的雷;</li>
<li>左键点击到没有雷的格子则在该格子上显示临近 8 个格子的雷的数量，若这 8 个格子存在显示为 0 的格子，则不显示，且继续扩散寻找该格子的临近的格子。</li>
<li>找到所有的雷时游戏成功，自动结束游戏;</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>set 和 map</title>
    <url>/2020/03/27/set%20%E5%92%8C%20map/</url>
    <content><![CDATA[<p>Map 和 Set 是 ES6 标准新增的数据类型 </p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 类似于数组，但是成员是唯一的。<br>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();  </span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//可以链式调用</span></span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>).add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时 s 的值是[1,2,3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可用于数组去重</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">435</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line"><span class="comment">//上述写法 arr1 是 Set 类型，可以用扩展运算符 ... 转换为数组类型</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [...new <span class="built_in">Set</span>(arr)];</span><br></pre></td></tr></table></figure>

<p>通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过delete(key)方法可以删除元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 类似于对象,是一组键值对的结构，具有极快的查找速度。<br>举个例子，假设要根据同学的名字查找对应的成绩，如果用 Array 实现，需要两个 Array：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'小明'</span>, <span class="string">'小红'</span>, <span class="string">'小刚'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">65</span>, <span class="number">74</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure>
<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array 越长，耗时越长。<br>但是，如果用 Map 实现，只需要一个 “姓名” - “成绩” 的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变。如下是一个 Map;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'小明'</span>,<span class="number">65</span>],[<span class="string">'小红'</span>,<span class="number">74</span>],[<span class="string">'小刚'</span>,<span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">'小明'</span>);</span><br><span class="line"><span class="comment">// 就会得到小明的成绩 65</span></span><br></pre></td></tr></table></figure>

<p>初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：<br>set、has、get、delete  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'小明'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'小红'</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">'小明'</span>); <span class="comment">// 是否存在key '小明': true</span></span><br><span class="line">m.get(<span class="string">'小明'</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">'小明'</span>); <span class="comment">// 删除key '小明'</span></span><br><span class="line">m.get(<span class="string">'小明'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值覆盖掉：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'小明'</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">'小明'</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">'小明'</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 用法笔记</title>
    <url>/2020/03/20/Promise-%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><em>Promise</em> 之前搞懂几次又忘记了，这次看了一篇写的很通俗易懂的 Promise 博文，所以记录下来。</p>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。Promise 里面保存着某个未来才会结束的事件(通常是一个异步操作)，会在 promise 结束时返回事件的结果。</p>
<a id="more"></a>
<h2 id="Promise-对象的特点"><a href="#Promise-对象的特点" class="headerlink" title="Promise 对象的特点"></a>Promise 对象的特点</h2><p>Promise 对象有以下两个特点：</p>
<ol>
<li>Promise 对象的状态不受外界影响，有三种状态：<code>pending</code>（进行中）、<code>resolve</code>（已成功）、<code>reject</code>（已失败）。Promise 里的异步操作的结果决定当前的状态，外部无法改变在这个状态。</li>
<li>Promise 的状态改变后就会保持这个状态不变，要不从 pending 变为 resolved ，要不从 pending 变为 rejected ，只要改变了，就会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>我们可以创建一个 promise 实例，从控制台输出这个 promise 实例，<code>[[PromiseStatus]]</code> 是 Promise  的状态，<code>[[PromiseValue]]</code> 是 Promise 的返回的值。</p>
<blockquote>
<p><em>pending 状态：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nmp = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">n,m</span>) =&gt;</span> &#123;</span><br><span class="line">     </span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nmp);</span><br></pre></td></tr></table></figure>

<p><img src="/images/artic/Promise-use/img-01.png" alt="截图"></p>
<p><em>resolved 状态：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nmp = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">//如果异步操作成功</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">       resolve(<span class="string">"对哦"</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       reject(<span class="string">"错的"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nmp);</span><br></pre></td></tr></table></figure>

<p><img src="/images/artic/Promise-use/img-02.png" alt="截图"></p>
<p><em>pending 状态：</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nmp = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">n,m</span>) =&gt;</span> &#123; </span><br><span class="line">     <span class="comment">//如果异步操作不成功</span></span><br><span class="line">     <span class="keyword">if</span>(!<span class="literal">true</span>)&#123;</span><br><span class="line">       resolve(<span class="string">"对哦"</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       reject(<span class="string">"错的"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nmp);</span><br></pre></td></tr></table></figure>

<p><img src="/images/artic/Promise-use/img-03.png" alt="截图"></p>
</blockquote>
<p><em>注意</em> 当我们用 new 创建一个 Promise 实例的时候，就会执行 Promise，如上。<br>所以我们用 Promise 的时候一般是放在一个函数中，在需要的时候调用这个函数，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">"promiseClick()"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'点击事件'</span>);</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'执行完成第一个 promise'</span>);</span><br><span class="line">      resolve(<span class="string">'返回的数据'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们点击 button 的时候，，就会执行 Promise ，先输出 ‘点击事件’，两秒后在输出‘执行完成 promise ’</p>
<p><img src="/images/artic/Promise-use/img-04.png" alt="截图"></p>
<p>Promise 可以调用 .then() 方法，所以让我们让函数的结果 return 出一个 Promise 对象。所以偶我们可以通过执行这个函数得到一个 Promise 对象，然后就可以用 Promise 对象的 then()、catch() 方法了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promiseClick()</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成第二个 promise'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">222</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成第三个 promise'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">333</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成第四个 promise'</span>);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/images/artic/Promise-use/img-05.png" alt="截图"></p>
<h3 id="resolve-和-reject-方法"><a href="#resolve-和-reject-方法" class="headerlink" title="resolve() 和 reject() 方法"></a>resolve() 和 reject() 方法</h3><p>实例化 Promise 对象时，传入一个参数，这个参数是一个函数，这个函数里有两个参数，一般习惯性命名 <code>resolve</code> 和 <code>reject</code>，它们也是两个函数。<code>resolve</code> 函数的作用是，当异步操作成功时，将异步操作的结果作为参数传递出去；<code>reject</code> 函数的作用是，当异步操作失败时，将异步操作的报错操作为参数传递出去。</p>
<p>我们可以通过 then() 方法获取 Promise 里的 <code>resolve</code> 和 <code>reject</code> 中传递的参数。<br>then() 方法接受两个回调函数作为参数，第一个回调函数对应的是 <code>resolved</code> 状态，第二个对应的是 <code>rejected</code> 的状态。也就是在成功时运行第一个回调函数，失败时运行第二个函数。如下，then() 方法的第一个参数接收的参数是 Promise 对象里 resolved 状态传出的值，即 resolve(num) 里的 num。第二个参数接收的参数是 Promise 对象里 rejected 状态传出的值，即 reject(‘数字大于10了，失败！’) 里的 ‘数字大于10了，失败！’。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'随机数:'</span> + num);</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">        resolve(num);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'数字大于10了，失败！'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'resolved 成功回调！'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'成功回调的值是：'</span> + res);</span><br><span class="line">      <span class="built_in">console</span>.log(pq);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'reject 失败回调！'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'失败执行回调抛出的失败原因：'</span> + reason);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 num 小于 10 时，Promise 状态变为 resolved，调用 then 里的第一个回调函数。</p>
<p><img src="/images/artic/Promise-use/img-06.png" alt="截图"></p>
<p>当 num 大于 10 时，Promise 状态变为 rejected，调用 then 里的第二个回调函数。</p>
<p><img src="/images/artic/Promise-use/img-07.png" alt="截图"></p>
<h3 id="catch-方法"><a href="#catch-方法" class="headerlink" title="catch() 方法"></a>catch() 方法</h3><p>与 Promise 对象方法 then 方法并行的一个方法就是 catch 方法，catch 就是用来捕获异常的，也就是和 then 方法中接受的第二参数 rejected 的回调是一样的，不同的是如果执行 resolved 的回调（也就是 then 的第一个参数）的时候报错了（如上一个例子 pq 就报错了），并不会报错卡死 js ，而是会进入 catch 方法中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'随机数:'</span> + num);</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">        resolve(num);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'数字大于10了，失败！'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolved 成功回调！'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'成功回调的值是：'</span> + res);</span><br><span class="line">    <span class="built_in">console</span>.log(pq);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'reject 失败回调！'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'失败执行回调抛出的失败原因：'</span> + reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/artic/Promise-use/img-08.png" alt="截图"></p>
<p>生成的 num 值是 5 ，进入 resolved 的回调，但是运行到 <code>console.log(pq)</code> 时，由于 <code>pq</code> 未定义报错，所以进入 catch 方法，接着执行。</p>
<h3 id="all-方法"><a href="#all-方法" class="headerlink" title="all() 方法"></a>all() 方法</h3><p>all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。由 Promise.all() 执行，all() 会接收一个数组，数组里包含着需要执行异步操作的所有方法，当这些操作都执行完后才会进入 Promise.all().then() 的 then() 里面，all() 方法会把所有异步操作的结果放到一个数组里传给 then()，然后执行 then() 方法，所有异步操作都是 <code>resolved</code>(已成功)状态时才会返回所有结果，否则不会进入 then 方法，就会报错或者进入写好的 catch() 方法。<br>如下，复制三个同样的 Promise 实例，分别为 promiseClick1、promiseClick2、promiseClick3。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promiseClick1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'随机数:'</span> + num);</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">        resolve(num);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'数字大于10了，失败！'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">promiseClick2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'随机数:'</span> + num);</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">        resolve(num);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'数字大于10了，失败！'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">promiseClick3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'随机数:'</span> + num);</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">        resolve(num);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'数字大于10了，失败！'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promiseClick1(), promiseClick2(), promiseClick3()])</span><br><span class="line">     .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(results);</span><br><span class="line">        &#125;)</span><br><span class="line">       .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(reason);</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>
<p>当三个都成功时，本案例是生成的 num 都小于 10时：</p>
<p><img src="/images/artic/Promise-use/img-09.png" alt="截图"></p>
<p>当三个没有都成功时，本案例是生成的 num 不都小于 10时，且没写 catch 方法时：</p>
<p><img src="/images/artic/Promise-use/img-10.png" alt="截图"></p>
<p>写了 catch ，则走 catch 方法：</p>
<p><img src="/images/artic/Promise-use/img-11.png" alt="截图"></p>
<p>这样以后就可以用 all 方法并行执行多个异步操作，并且在一个回调中处理所有的返回数据，比如你需要提前准备好所有数据才渲染页面的时候就可以使用all,执行多个异步操作将所有的数据处理好，再去渲染。</p>
<h3 id="race-方法"><a href="#race-方法" class="headerlink" title="race() 方法"></a>race() 方法</h3><p>race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。但是和 all 方法相反，它是谁先执行完就先执行回调，不管是失败还是成功，都返回唯一的结果，不管后面的的执行的结果。之后执行完的都不会进入 race 的回调。<br>例如，将上面的方法延迟改为 1s 2s 3s，1s 后 promiseClick1 执行完成，返回结果，进入 race 方法，但是  promiseClick2 和 promiseClick3 并没有停止，会在 2s 和 3s 或执行完。但是不会进入 race 的回调。和 all 一样，race 的回调也只会执行一次，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promiseClick1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'随机数:'</span> + num);</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= <span class="number">10</span>)</span><br><span class="line">        resolve(num);</span><br><span class="line">      reject(<span class="string">'数字大于10了，失败！'</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">promiseClick2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'随机数:'</span> + num);</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= <span class="number">10</span>)</span><br><span class="line">        resolve(num);</span><br><span class="line">      reject(<span class="string">'数字大于10了，失败！'</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">promiseClick3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'随机数:'</span> + num);</span><br><span class="line">      <span class="keyword">if</span>(num &lt;= <span class="number">10</span>)</span><br><span class="line">        resolve(num);</span><br><span class="line">      reject(<span class="string">'数字大于10了，失败！'</span>);</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promiseClick1(), promiseClick2(), promiseClick3()])</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'成功'</span> + data);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'失败'</span> + reason);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>成功时：</p>
<p><img src="/images/artic/Promise-use/img-12.png" alt="截图"></p>
<p>失败时：</p>
<p><img src="/images/artic/Promise-use/img-13.png" alt="截图"></p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设定 5 秒超时</span></span><br><span class="line">timeout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">'请求超时！'</span>);</span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求</span></span><br><span class="line">requist = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 数据请求等异步操作</span></span><br><span class="line">      resolve(res);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([timeout(), requist()]);</span><br><span class="line">       .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log</span><br><span class="line">        &#125;)</span><br><span class="line">       .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.error</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果 5 秒之内数据请求无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数。</p>
<h3 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h3><ol>
<li><a href="https://es6.ruanyifeng.com/?search=promise&x=6&y=11#docs/promise" target="_blank" rel="noopener external nofollow noreferrer">ES6 Promise 对象</a></li>
<li><a href="https://blog.csdn.net/qq_34645412/article/details/81170576" target="_blank" rel="noopener external nofollow noreferrer">ES6 Promise用法小结</a>         </li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-有效的数独</title>
    <url>/2020/03/03/LeetCode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<a id="more"></a>
<p><img src="/images/artic/LeetCode/02/img-01.png" alt="截图"> </p>
<p>上图是一个部分填充的有效的数独。</p>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><em>解释:</em><br>除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p>
<p><em>说明:</em><br>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>本题的要求是判断该九宫格的每行每列和每个小的九宫格是否含有相同的数字，如果含有则报错。<br>我的思路是把对应的行、列、小宫格里的数据都保存到一个新的数组里，然后用 sort() 方法排序，再从前到后判断一下前一个数是否和后一个数相等。</p>
<blockquote>
<ol>
<li>判断行  </li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">var</span> a = arr2[i];</span><br><span class="line">   a.sort();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">8</span>; a[j]*<span class="number">1</span>; j--)&#123;</span><br><span class="line">   	<span class="keyword">if</span>(a[j] === a[j<span class="number">-1</span>])&#123;</span><br><span class="line">   	    <span class="comment">// console.log(a);</span></span><br><span class="line">   	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>判断列</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查列   </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">	b.push(arr1[j][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(b);</span></span><br><span class="line">b.sort();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">8</span>; b[j]*<span class="number">1</span>; j--)&#123;</span><br><span class="line">	<span class="keyword">if</span>(b[j] === b[j<span class="number">-1</span>])&#123;</span><br><span class="line">		<span class="comment">// console.log(b);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>判断小宫格<br>划分出每个小宫格是我认为最难的地方，每个小宫格对应的下标是<br><img src="/images/artic/LeetCode/02/img-02.png" alt="截图"><br>可以看出：  </p>
<ul>
<li>第一个小宫格的行下标小于3、列下标小于3;</li>
<li>第二个小宫格的行下标小于3、列下标小于6，</li>
<li>第三个小宫格的行下标小于3、列下标小于9，</li>
<li>第四个小宫格的行下标小于6、列下标小于3，</li>
<li>第五个小宫格的行下标小于6、列下标小于6，</li>
<li>第六个小宫格的行下标小于6、列下标小于9，</li>
<li>第七个小宫格的行下标小于9、列下标小于3，</li>
<li>第八个小宫格的行下标小于9、列下标小于6，</li>
<li>第九个小宫格的行下标小于9、列下标小于9，</li>
</ul>
<p>可以发现 3 6 9 是关键值，所以每次循环使用 3 来做为增加的值。第一层 for 循环设置行的下标变量 i 的初始值为 0，每次循环加 3，再定义一个变量 ii，用于判断每个小宫格的行下标的范围。第二层 for 循环设置列的下标变量 j 的初始值为 0，没次循环加 3，再定义一个变量 jj，用于判断每个小宫格的列下标的范围。然后定义一个空数组 c ，用来保存每次循环出的小宫格里的数字。此时我们打印出 ii 和 jj，可以发现就是上面对应的每个小宫格的行下标和列下标的范围</p>
</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下标范围：</span><br><span class="line">    3 3</span><br><span class="line">    3 6</span><br><span class="line">    3 9</span><br><span class="line">    6 3</span><br><span class="line">    6 6</span><br><span class="line">    6 9</span><br><span class="line">    9 3</span><br><span class="line">    9 6</span><br><span class="line">    9 9</span><br></pre></td></tr></table></figure>
<p>接下来用两个 for 循环把每个小宫格里的数字保存到上面的空数组 c 里就可以，因为这里的循环会把 i 和 j 加 3 所以记得在对应的行和列的循环完成后把 i 和 j 减 3。这样才和外层的循环对应的上。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查小宫格</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i+=<span class="number">3</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> ii = i + <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j+=<span class="number">3</span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> jj = j + <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">var</span> c = [];</span><br><span class="line">       <span class="comment">//console.log(ii, jj)</span></span><br><span class="line">       <span class="keyword">for</span>(i; i &lt; ii; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(j; j &lt; jj; j++)&#123;</span><br><span class="line">               c.push(arr3[i][j]);</span><br><span class="line">           &#125;</span><br><span class="line">           j = jj - <span class="number">3</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       i = ii - <span class="number">3</span>;</span><br><span class="line">       c.sort();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">8</span>; c[k]*<span class="number">1</span>; k--)&#123;</span><br><span class="line">           <span class="keyword">if</span>(c[k] === c[k<span class="number">-1</span>])&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们行、列和小宫格都判断完了，如果没有重复的我们就 <code>return true</code>。由于 sort 会改变原数组的排列，所以我定义了三个新的数组用于行、列和小宫格的判断。</p>
</blockquote>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;character[][]&#125;</span> <span class="variable">board</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(board));</span><br><span class="line">	<span class="keyword">var</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(board));</span><br><span class="line">	<span class="keyword">var</span> arr3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(board));</span><br><span class="line">    <span class="comment">// 检查行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">    	<span class="keyword">var</span> a = arr1[i];</span><br><span class="line">    	a.sort();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">8</span>; a[j]*<span class="number">1</span>; j--)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(a[j] === a[j<span class="number">-1</span>])&#123;</span><br><span class="line">    			<span class="comment">// console.log(a);</span></span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查列   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">    	<span class="keyword">var</span> b = [];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">    		b.push(arr2[j][i]);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// console.log(b);</span></span><br><span class="line">    	b.sort();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">8</span>; b[j]*<span class="number">1</span>; j--)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(b[j] === b[j<span class="number">-1</span>])&#123;</span><br><span class="line">    			<span class="comment">// console.log(b);</span></span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查九宫格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i+=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> ii = i + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j+=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> jj = j + <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">var</span> c = [];</span><br><span class="line">            <span class="keyword">for</span>(i; i &lt; ii; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j; j &lt; jj; j++)&#123;</span><br><span class="line">                    c.push(arr3[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                j = jj - <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// console.log(i);</span></span><br><span class="line">            i = ii - <span class="number">3</span>;</span><br><span class="line">            <span class="comment">// console.log(c);</span></span><br><span class="line">            c.sort();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">8</span>; c[k]*<span class="number">1</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c[k] === c[k<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="comment">// console.log(c);</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-旋转图像</title>
    <url>/2020/03/03/LeetCode-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%20copy/</url>
    <content><![CDATA[<h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<a id="more"></a>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[          </span><br><span class="line">  [1,2,3],  </span><br><span class="line">  [4,5,6],  </span><br><span class="line">  [7,8,9]  </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为: </span><br><span class="line">[  </span><br><span class="line">  [7,4,1],  </span><br><span class="line">  [8,5,2],  </span><br><span class="line">  [9,6,3]  </span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[  </span><br><span class="line">  [ 5, 1, 9,11],  </span><br><span class="line">  [ 2, 4, 8,10],  </span><br><span class="line">  [13, 3, 6, 7],  </span><br><span class="line">  [15,14,12,16]  </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[  </span><br><span class="line">  [15,13, 2, 5],  </span><br><span class="line">  [14, 3, 4, 1],  </span><br><span class="line">  [12, 6, 8, 9],  </span><br><span class="line">  [16, 7,10,11]  </span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>要实现数组图像的旋转我们可以看做是把数组的第一行变成最后一列，第二行变成倒数第二列，依次类推…<br><img src="/images/artic/LeetCode/01/img-01.png" alt="截图"><br>但是题目规定要在原数组内修改，所以我们可以在每一行的后面加上对应的列，最后再删除前面的原数组对应的列，就得到我们旋转过后的图像。<br><img src="/images/artic/LeetCode/01/img-02.png" alt="截图">4</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> c = count - <span class="number">1</span>; c &gt;= <span class="number">0</span>; c--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i  = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            matrix[i].push(matrix[c][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> c = <span class="number">0</span>; c &lt; count; c++)&#123;</span><br><span class="line">        matrix[c].splice(<span class="number">0</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 实例的生命周期</title>
    <url>/2020/03/01/Vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="什么是生命周期"><a href="#什么是生命周期" class="headerlink" title="什么是生命周期"></a>什么是<em><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener external nofollow noreferrer">生命周期</a></em></h2><p>Vue 从实例的创建、运行到销毁，都要经过一系列的过程，这些过程其过程中发生的事件就叫做生命周期，就像听起来一样，它记录了 Vue 实例由创建到销毁的整个过程。  <a id="more"></a></p>
<h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a><em>生命周期钩子</em></h2><p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener external nofollow noreferrer">生命周期钩</a>是记录 Vue 实例生命周期中所发生的一些初始化的过程的函数，也叫生命周期事件、生命周期函数，例如 <code>created</code>、<code>mounted</code>、<code>updated</code> 和 <code>destroyed</code>等，这些生命周期钩子在 Vue 实例生命周期的不同阶段被调用，我们可以通过它们在 Vue 实例的不同阶段进行操作。  </p>
<h2 id="Vue-实例的生命周期函数分类"><a href="#Vue-实例的生命周期函数分类" class="headerlink" title="Vue 实例的生命周期函数分类"></a>Vue 实例的生命周期函数分类</h2><p>我们可以根据生命周期函数的不同，把生命周期函数分为三类：</p>
<ol>
<li><p>创建期间的生命周期函数：</p>
<ul>
<li><p><em>beforeCreate（创建前）</em>: 实例完全创建出来之前会调用它，此时刚在内存中创建出实例，还没有初始化好 data 和 methods 属性，我们此时无法调用 data 和 methods 里的数据和方法</p>
<p><img src="/images/artic/lifecycle/img-1.png" alt="截图"><br><img src="/images/artic/lifecycle/img-2.png" alt="截图"></p>
</li>
<li><p><em>created（创建后）</em>： 实例已经创建完毕，date 和 methods 属性也初始化完毕,但是 el还未初始化，还没开始编译模板；</p>
</li>
<li><p><em>beforeMount（挂载前）</em>： 已经完成了模板的编译，把 data 里面的数据和模板生成 html，但是还没有挂载到页面中；</p>
</li>
<li><p><em>mounted（挂载后）</em>: 已经将编译好了的模板的 html 内容替换 el 属性指向的 DOM 对象，把模板中的 html 渲染到真实地 html 页面中；</p>
</li>
</ul>
</li>
<li><p>运行期间的生命周期函数：</p>
<ul>
<li><em>beforeUpdate（更新前）</em>： 此时 data 中的数据已经是更新完了的，但还没有重新开始渲染 DOM 中的节点，所以页面上显示的还是旧的数据</li>
<li><em>updated（更新后）</em>： 此时 data 和 界面上的数据都更新完毕，界面也重新渲染完毕。应该避免在此期间更改状态，因为这可能会导致更新无限循环；</li>
</ul>
</li>
<li><p>销毁期间的生命周期函数：</p>
<ul>
<li><em>beforeDestroy（销毁前）</em>：实例销毁之前调用，此时实例还可以完全使用；</li>
<li><em>destroyed（销毁后）</em>： 实例销毁后调用，调用后 Vue 实例上所有的数据状态和事件都会解除绑定或被移除，所有的子实例也都会被销毁。</li>
</ul>
</li>
</ol>
<p><img src="/images/artic/lifecycle/lifecycle.jpg" alt="截图"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex简介</title>
    <url>/2020/02/27/Vuex%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，按我的理解就是就是一个监控全局状态的一个库，储存在这个库里的数据变化了，各个组件在使用时都会同步变化，省去了组件间反复交错传值的麻烦,即储存在 Vuex 里的数据是响应式的。</p>
<a id="more"></a>
<h2 id="如何使用-Vuex"><a href="#如何使用-Vuex" class="headerlink" title="如何使用 Vuex"></a>如何使用 Vuex</h2><p>我们首先要在项目里安装 Vuex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure>
<p>然后我们创建一个 store，Vuex 的核心就是 store（仓库），创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一般在项目中，我们都在 src 目录下创建一个 store 文件夹，然后创建对应的 js 文件，免得State 、 Mutation、 Getter 和 Action 等都混杂在一个文件里，方便以后的改动。</p>
<p><img src="/images/artic/vuex/img-1.png" alt="截图"><br>然后初始化 store，在 index.js 里引入相关的 state.js、mutations.js、getters.js、actions.js</p>
<p><img src="/images/artic/vuex/img-2.png" alt="截图"></p>
<p>并在 main.js 里挂载 store。</p>
<p><img src="/images/artic/vuex/img-3.png" alt="截图"></p>
<h2 id="Vuex-的核心概念"><a href="#Vuex-的核心概念" class="headerlink" title="Vuex 的核心概念"></a>Vuex 的核心概念</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote>
<p>Vuex 使用单一状态树，即 Vuex 仅用一个 state 对象来保存所有的数据状态，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//state.js</span></span><br><span class="line"><span class="comment">// 创建 state 对象</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  count: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state</span><br></pre></td></tr></table></figure>
<p>例如我们创建了一个 state 对象，里面有一个 count 属性。在 Vuex 可以通过 store.state.conut 调用它。在模块化组件中使用 算属性返回 state 里面的值,有如下两种方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 mapState 函数时要提前引入 mapState 函数</span></span><br><span class="line"> <span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'XXX'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 方法一  mapState 辅助函数</span></span><br><span class="line">    ...mapState([<span class="string">'count'</span>]),</span><br><span class="line">    <span class="comment">// 或者 方法二</span></span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在 html 中使用时直接 {{count}} 引用就行。

</blockquote>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><blockquote>
<p>getter就是取值，可以认为是 store 的计算属性，就像计算属性一样，getter 的返回值会根据它的依赖值改变而重新计算。getter 接受 state 作为其第一个参数，也可以接受其他的 getter 作为第二个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getters.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  cartLength(state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.cartList.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  cartProduct(state) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.cartList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 Vue 中也有两种方式访问到 getter 的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 mapGetters 函数时要提前引入 mapGetters 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> name: <span class="string">'XXX'</span>,</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> computed: &#123;</span><br><span class="line">   <span class="comment">// 方法一  mapGetters 辅助函数</span></span><br><span class="line">   ...mapGetters([<span class="string">'cartLength'</span>,<span class="string">'cartProduct'</span>]),</span><br><span class="line">   <span class="comment">// 或者 方法二</span></span><br><span class="line">   cartLength() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.cartLength;</span><br><span class="line">   &#125;,</span><br><span class="line">   cartProduct() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.cartProduct;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在 html 中的使用方法也是用 {{}} 直接引用。

</blockquote>
<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><blockquote>
<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，mutation 是直接改变 state 中的具体的数据状态的地方，最直接的增删改都是在 mutation 中发生的，mutations 中的每个方法尽可能完成比较单一的事，具体的判断交给我们等下提到的 Action。我们通过调用 store.commit 方法提交 mutation，mutation 的第一个参数为 state，还可以传入额外的参数，即 mutation 的 载荷（payload）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mutations.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  subtract(state)&#123;</span><br><span class="line">    state.count--;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//传入的 payload 是数字</span></span><br><span class="line">  increase(state, n)&#123;</span><br><span class="line">    state.count += n;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//一般来讲 payLoad 应该是一个对象</span></span><br><span class="line">  cut_off(state, payLoad)&#123;</span><br><span class="line">    <span class="keyword">delete</span> state.payLoad;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上在 mutation 里我们应该尽量完成者增删改这种简单的操作。</p>
</blockquote>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote>
<p>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态,即上面所说的判断具体的该不该增删改查的操作在 Action 中进行。而且在 Action 中的参数不是 state ，而是一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。Action 通过 store.dispatch 方法来提交。<br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">   name: <span class="string">'XXX'</span>,</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   methods:&#123;</span><br><span class="line">     reduce() &#123;</span><br><span class="line">       <span class="keyword">this</span>.$store.dispatch(<span class="string">'reduce'</span>,item);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们提交了一个 dispatch 触发了 Action</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  reduce(context, payLoad) &#123;</span><br><span class="line">    <span class="comment">//提交 commit 触发上面 mutation 里的 subtract 方法。</span></span><br><span class="line">    context.commit(subtract);</span><br><span class="line">    <span class="comment">//如果 当前对象的 count 是 0，就提交 commit 触发上面 mutation 里的 cut_off 方法，删除当前的对象。</span></span><br><span class="line">    <span class="keyword">if</span>(payLoad.count === <span class="number">0</span>) &#123;</span><br><span class="line">      context.commit(cut_off,payLoad);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 面试题 1-5</title>
    <url>/2020/02/23/Vue-%E9%9D%A2%E8%AF%95%E9%A2%98-1-5/</url>
    <content><![CDATA[<h2 id="1-MVVM-原理的理解"><a href="#1-MVVM-原理的理解" class="headerlink" title="1.MVVM 原理的理解"></a>1.MVVM 原理的理解</h2><p>传统的架构模型是 MVC，即 <code>Model - View - Controller</code>，是用户操作会请求服务端路由，路由会调用对应的控制器来处理，控制器会获取数据，将结果返回给前端，页面重新渲染。<a id="more"></a><br>MVVM 是 <code>Model - ViewModel - View</code>，MVVM 模式不需要用户手动操纵 dom 元素，将数据绑定到 ViewModel 层上，Vue 会自动将数据渲染到页面中，视图变化会通知 ViewModel 层更新数据，通过 ViewModel 层连接 View 层和 Model 层。MVVM 就是一个双向绑定的过程，数据变化会驱动视图变化，视图变化也会更改数据。</p>
<h2 id="2-响应式数据的原理"><a href="#2-响应式数据的原理" class="headerlink" title="2.响应式数据的原理"></a>2.响应式数据的原理</h2><blockquote>
<h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><ol>
<li>核心点：object.defineProperty()。</li>
<li>默认 Vue 在初始化数据时，会给 data 中的属性使用 Object.defineProperty 重新定义所有属性，当页面使用到对应属性时，会进行依赖手机（数当前组件的 Watcher）如果属性发生变化会通知相关依赖进行更新操作。  <h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><img src="/images/artic/Vue-mst-1-5/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png" alt="截图"></li>
</ol>
</blockquote>
<h2 id="3-Vue中时如何检测数组变化的？"><a href="#3-Vue中时如何检测数组变化的？" class="headerlink" title="3.Vue中时如何检测数组变化的？"></a>3.Vue中时如何检测数组变化的？</h2><blockquote>
<h3 id="理解：-1"><a href="#理解：-1" class="headerlink" title="理解："></a>理解：</h3><p>使用函数劫持的方式，重写数组的方法。<br>Vue 将 data 中的数组进行了原型链上的重写，指向了自己定义的数组原型方法，这样当调用数组 API 时，可以通知依赖更新，如果数组中包含引用类型，会对引用类型再次进行监控。</p>
<h3 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h3><p><img src="/images/artic/Vue-mst-1-5/%E6%95%B0%E7%BB%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.png" alt="截图">  </p>
</blockquote>
<h2 id="4-为何-Vue-采用异步渲染？"><a href="#4-为何-Vue-采用异步渲染？" class="headerlink" title="4.为何 Vue 采用异步渲染？"></a>4.为何 Vue 采用异步渲染？</h2><blockquote>
<h3 id="理解：-2"><a href="#理解：-2" class="headerlink" title="理解："></a>理解：</h3><p>因为 Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能考虑，Vue 会在本轮数据更新后，再去异步更新视图。</p>
<h3 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h3><p><img src="/images/artic/Vue-mst-1-5/%E4%B8%BA%E4%BD%95%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93.png" alt="截图"></p>
</blockquote>
<h2 id="5-nextTick-实现原理"><a href="#5-nextTick-实现原理" class="headerlink" title="5.nextTick 实现原理"></a>5.nextTick 实现原理</h2><blockquote>
<h3 id="理解：-3"><a href="#理解：-3" class="headerlink" title="理解："></a>理解：</h3><p>nextTick 方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列，所以这个 nextTick 方法就是异步方法。</p>
<h3 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a>原理：</h3><p><img src="/images/artic/Vue-mst-1-5/nextTick%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.png" alt="截图"></p>
</blockquote>
<h2 id="6-Vue-中-Computed-的特点"><a href="#6-Vue-中-Computed-的特点" class="headerlink" title="6. Vue 中 Computed 的特点"></a>6. Vue 中 Computed 的特点</h2><blockquote>
<h3 id="理解：-4"><a href="#理解：-4" class="headerlink" title="理解："></a>理解：</h3><p>默认 computed 也是一个 watcher ，是具备缓存功能的，只有当依赖的属性发生变化是才会更新视图。和 methods 不一样，computed 里的方法在渲染时，如果依赖的属性不变，不会重新执行，而 methods 里的方法在渲染时不管数据有没有变化都会执行。<br>computed 和 watch 内部都是使用 watcher 来实现的，但是 computed 具备缓存。</p>
<h3 id="原理：-4"><a href="#原理：-4" class="headerlink" title="原理："></a>原理：</h3><p><img src="/images/artic/Vue-mst-1-5/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7.png" alt="截图"></p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>OOP 面对对象编程</title>
    <url>/2020/02/21/OOP-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>OOP 是一种编程范式，或者一种编程风格，围绕着对象而不是函数展开，很多你感兴趣的框架实际上都是基于 OOP 设计的。面向对象编程可以使你的代码更加简洁、优雅，避免你一遍遍地复制和粘贴代码行。<a id="more"></a>面向对象编程有四个核心概念，即 <code>封装</code>、<code>抽象</code>、<code>继承</code> 和 <code>多态</code>。<br>OOP 将一组相关的变量和函数组合成一个单元，即我们所称的对象（object）。我们把里面的变量成为[属性]（Property），函数称为[方法]（Method） </p>
<h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h3><blockquote>
<p>我们把属性和操作属性的方法组合到对象中，就是一种封装。<br>例如下面这种计算工资的方式是一种面向过程的编程：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> baseSalary = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">let</span> overtime = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> rate = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWage</span>(<span class="params">babaseSalary, overtime, rate</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> babaseSalary + (overtime * rate);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而面向对象的编程方式是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> employee = &#123;</span><br><span class="line"> baseSalary: <span class="number">3000</span>,</span><br><span class="line"> overtime: <span class="number">10</span>,</span><br><span class="line"> rate: <span class="number">22</span>,</span><br><span class="line"> getWage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.baseSalary + (<span class="keyword">this</span>.overtime * <span class="keyword">this</span>.rate);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">employee.getWage();</span><br></pre></td></tr></table></figure>
<p><code>baseSalary</code>,<code>overtime</code> 和 <code>rate</code> 是 employee 对象的属性， <code>getWage</code> 是 employee 对象的方法。面向过程的编程方式的特点的函数具有多个参数，而面向对象的方法所需要的参数会越来越少，使用和维护起来也更容易，这也是一种简单的封装。</p>
</blockquote>
<h3 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h3><blockquote>
<p>我们把对象的一些复杂的属性和方法隐藏起来，只对外暴露一些简单的属性和方法。这样可以使对象的接口更简单，因为使用具有几个属性和方法的对象比具有多个属性和方法的对象要容易；而且有助于我们减少变化的影响，因为我们没有任何代码让别人在对象之外接触到我们隐藏的方法。</p>
</blockquote>
<h3 id="继承-Inherittance"><a href="#继承-Inherittance" class="headerlink" title="继承 Inherittance"></a>继承 Inherittance</h3><blockquote>
<p>继承是一种机制，可以减少程序的冗余代码。例如我们的文本框、下拉列表、复选框等HTML元素都有很多相同的属性和方法，如果我们每个元素都重新定义多有这些属性和方法，就有很多多余代码。所以我们可以只在通用对象中定义一次，然后让其他元素继承这个元素。</p>
</blockquote>
<h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h3><blockquote>
<p>多态是一种技术，它可以让我们摆脱冗长的 <code>if/else</code> 或 <code>switch/case</code> 语句。不同的元素在页面上有不同的渲染方式，如果使用面向过程的方式呈现多个HTML元素，我们可能会使用很多 <code>if/else</code> 或者 <code>switch/case</code>，例如：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (...) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'select'</span>: renderSelect();</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'text'</span>: renderTextBox();</span><br><span class="line"> <span class="keyword">case</span> <span class="string">'checkbox'</span>: renderCheckBox();</span><br><span class="line"> <span class="keyword">case</span> ...</span><br><span class="line"> <span class="keyword">case</span> ...</span><br><span class="line"> <span class="keyword">case</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在 OOP 中，我们可以在每个对象中实现一个渲染方法，渲染方法会根据引用的对象的类型不同而不同，使用如下简化代码 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.render()</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="面向对象编程的好处"><a href="#面向对象编程的好处" class="headerlink" title="面向对象编程的好处"></a>面向对象编程的好处</h2><ul>
<li>使用封装重新组合相关变量和函数， 减少复杂性，使我们在不同的地方重复使用这些对象。</li>
<li>通过抽象，我们隐藏细节和复杂性，只显示必要的部分，降低了复杂性，也隔离的代码更改的影响。</li>
<li>继承让我们消除多余的代码。</li>
<li>多态可以让我们避免写出复杂的选择性代码。</li>
</ul>
<h1 id="对象的基本概念"><a href="#对象的基本概念" class="headerlink" title="对象的基本概念"></a>对象的基本概念</h1><p>JavaScript的对象实际上是一组键值对的集合，我们可以通过 <code>var</code>、<code>let</code>、<code>const</code>来创建一个对象，使用 let 我们创建一个可以重新声明的变量，使用 const 我们创建一个不可以重新声明的常量。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的大括号表示创建一个对象，我们在大括号内加入的键值对就是这个对象的属性，如果是函数，我们可以称为方法。例如以下的 radius 和 location 就是属性，draw 就是方法。<em>属性是用来保存值的，而方法或函数是用来定义一些逻辑的</em>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">  radius: <span class="number">1</span>,</span><br><span class="line">  location: &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  draw: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以通过点语法调用对象的属性或方法，对象创建语法是一种简单的定义对象的方法，如果我们需要创建其他的几个拥有一些相同属性或方法的对象，我们可能会通过 <kbd>Ctrl</kbd> + <kbd>V</kbd> 来复制之前的代码，但是这样容易出错，同时如果以后要改这些相同的属性或方法也非常麻烦，因为我们复制了多少份就得改多少个地方，所以对象创建语法不是好的复制对象的方法。如果对象中有多个方法，我们就说对象具有行为性，因为可以干多个不同的事，所以我们可以通过<em>工厂函数<em>（factory）和</em>构造函数</em> （constructor）创建对象来解决这个问题。</p>
<h2 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h2><p>ES6新特性，如果键和值的名字一样，我们可以去除多余的代码，只写一个键或者值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		radius, </span><br><span class="line">		draw: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = createCircle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以通过调用上面的工厂函数来创建一个新的 cirlce 对象。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建构造函数的命名规则不一样，要大写第一个字母。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> another = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>我们也可以通过调用上面的构造函数来创建一个新的 cirlce 对象。<br>当使用 new 操作符调用一个函数时，会发生3件事  </p>
<ol>
<li>首先 new 操作符创建了一个空对象</li>
<li>然后设置this指向这个对象</li>
<li>最后它从函数返回这个对象</li>
</ol>
<p>此时 this 指向我们创建的 Circle 对象：<br><img src="/images/artic/OPP-1/img-01.png" alt="截图"></p>
<p>默认情况下 this 会指向全局对象，如果在浏览器环境运行，全局对象就是 window 对象，如果在 node.js 环境运行，全局对象就是 global 。如果我们删除 new 操作符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> another = Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>this 就会指向 window 对象：<br><img src="/images/artic/OPP-1/img-02.png" alt="截图"></p>
<p>每个 JavaScript 中的对象都有一个 constructor 属性，它是一个用于创建这个对象的构造方法的引用。例如我们在控制台中输入 another.constructor ，会返回一个 Circle 函数，就是我们刚才创建的那个。<br><img src="/images/artic/OPP-1/img-03.png" alt="截图"></p>
]]></content>
      <categories>
        <category>OPP面对对象</category>
      </categories>
      <tags>
        <tag>OPP面对对象</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题一</title>
    <url>/2020/02/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/</url>
    <content><![CDATA[<h2 id="1-call-和-apply-的区别？"><a href="#1-call-和-apply-的区别？" class="headerlink" title="1. call 和 apply 的区别？"></a>1. call 和 apply 的区别？</h2><p>call 和 apply 都可以改变 this 的指向，如下，都是把 B 的 this 指向 A，即使用的是 A 的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A.call(B, argument1， argument2, ...);</span><br><span class="line">A.apply(B, [argument1， argument2, ...]);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>不同的是后面传递的参数：</p>
<ul>
<li>call 后面的参数直接加入就行<br><code>Obj1.sayHello.call(Obj2, &quot;张三&quot;, 18)</code> </li>
<li>apply 后面的参数要用类似数组的方式加入<br><code>Obj1.sayHello.apply(Obj2, [&quot;张三&quot;, 18])</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name= <span class="string">'NO.A'</span></span><br><span class="line">  <span class="keyword">this</span>.say= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name= <span class="string">'NO.B'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>
此时方法 say 的 this 指向它的上级 A，所以我们在控制台输入 a.say() 时输出的是 NO.A，</li>
</ul>
<p><img src="/images/artic/qdmst01/img-1.png" alt="截图"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name= <span class="string">'NO.A'</span></span><br><span class="line">  <span class="keyword">this</span>.say= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    B.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name= <span class="string">'NO.B'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>
<p>当我们用 <code>B.call(this)</code> 把this的指向变为了 B 对象，所以控制台输入 a.say() 时输出的是 NO.B</p>
<p><img src="/images/artic/qdmst01/img-2.png" alt="截图"></p>
<h2 id="2-JavaScript-如何实现继承？"><a href="#2-JavaScript-如何实现继承？" class="headerlink" title="2. JavaScript 如何实现继承？"></a>2. JavaScript 如何实现继承？</h2><p>原型链继承、借用构造函数继承、寄生式继承  </p>
<ul>
<li>原型链继承，js 的每个对象的原型对象都有一个 constructor 属性，指向这个对象的构造函数，每个对象的实例都有一个 <strong>proto</strong> 属性，指向这个对象的原型。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'你好我是'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Person(<span class="string">'小明'</span>);</span><br></pre></td></tr></table></figure>
Person 没有 say() 方法，但是，我们通过 prototype 给 Person 的原型 Object 上添加了 say()方&gt;法，所以我们通过 Person 建立的实例 m 也能用 say() 方法，在控制台中输入 m.say() </li>
</ul>
<p><img src="/images/artic/qdmst01/img-3.png" alt="截图"></p>
<p>可以看到，我们的 say 方法执行了，同时，我们输入 m ，可以看到 m 的属性。我们可以 通过 m.toString() 来调用 Object 对象里的方法，也可以改写该方法。</p>
<p><img src="/images/artic/qdmst01/img-4.png" alt="截图">  </p>
<ul>
<li><p>借用构造函数继承，也叫经典继承，这种技术的基本思想相当简单，即在子类型的构造函数内部调用类型的构造函数，&gt;可以通过 call() 或 apply() 方法在新创建的对象上执行构造函数，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  Box.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> one = <span class="keyword">new</span> Box(<span class="string">'大王'</span>);</span><br><span class="line"><span class="keyword">const</span> tow = <span class="keyword">new</span> Son(<span class="string">'小王'</span>，<span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/images/artic/qdmst01/img-5.png" alt="截图"></p>
</li>
<li><p>组合继承,指的是将原型链和借用构造函数的奇数组合到一块，从而发挥两者长处的一种继承方式。其思路是利用原型链实现对原型属性和方法的继承，通过构造函数实现对实例的属性方法的继承，既通过在原型上定义实现了函数方法的复用，又能保证每个实例都有自己的属性。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.include = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是'</span> + <span class="keyword">this</span>.name + <span class="string">',我今年'</span> <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//继承属性</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">  <span class="keyword">this</span>.job=job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">Worker.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Worker.prototype.constructor = Worker;<span class="comment">// 更改 constructor 指向</span></span><br><span class="line">Worker.prototype.myJob=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我的工作是'</span> + <span class="keyword">this</span>.job)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mimg = <span class="keyword">new</span> Worker(<span class="string">'小明'</span>, <span class="number">18</span>, <span class="string">'搬砖'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mine);</span><br><span class="line">ming.include();</span><br><span class="line">ming.myJob();</span><br></pre></td></tr></table></figure>
<p><img src="/images/artic/qdmst01/img-6.png" alt="截图"></p>
</li>
<li><p>寄生式继承的思路与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">org</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="built_in">Object</span>(org);   <span class="comment">//调用函数时会创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你好！'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'小明'</span>,</span><br><span class="line">  ageL: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newPerson = createPerson(person);</span><br><span class="line"></span><br><span class="line">newPerson.sayHi();</span><br></pre></td></tr></table></figure>
<p><img src="/images/artic/qdmst01/img-7.png" alt=""><br>上面的例子中，新对象 newPerson 不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法，任何能返回新对象的函数都适用于此模式。  </p>
<h2 id="3-JavaScript-创建对象的几种方式？"><a href="#3-JavaScript-创建对象的几种方式？" class="headerlink" title="3. JavaScript 创建对象的几种方式？"></a>3. JavaScript 创建对象的几种方式？</h2><ol>
<li>对象字面量、Object构造函数</li>
<li>构造函数  </li>
<li>纯构造函数  </li>
<li>空构造函数 + 原型  </li>
<li>混合构造函数 + 原型  </li>
<li>动态原型<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, work</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="comment">//动态原型的方式  </span></span><br><span class="line">  <span class="keyword">if</span>(work) &#123;</span><br><span class="line">    Person.prototype.working = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'我的工作是'</span> + work);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>寄生构造函数  </li>
<li>Object.create()—-ES5  </li>
</ol>
<h2 id="4-JavaScript-this-指针、闭包、作用域"><a href="#4-JavaScript-this-指针、闭包、作用域" class="headerlink" title="4. JavaScript this 指针、闭包、作用域"></a>4. JavaScript this 指针、闭包、作用域</h2><p>this： 指向调用上下文<br>闭包： 外层函数能访问内层函数的变量<br>作用域： 定义一个函数就开辟一个局部作用域，整个 js 执行环境有一个全局作用域  </p>
<h2 id="5-如何阻止事件冒泡和默认事件"><a href="#5-如何阻止事件冒泡和默认事件" class="headerlink" title="5. 如何阻止事件冒泡和默认事件"></a>5. 如何阻止事件冒泡和默认事件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">e.stopPropagation();  <span class="comment">//标准浏览器阻止事件冒泡  </span></span><br><span class="line">event.canceBubble=<span class="literal">true</span>;  <span class="comment">//ie9之前阻止默认事件</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/02/13/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="什么是-Markdown-？"><a href="#什么是-Markdown-？" class="headerlink" title="什么是 Markdown ？"></a>什么是 Markdown ？</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markown 编写的文档后缀名为 <code>.md</code> 或者 <code>.markdown</code>。Markdown 被广泛应在在各种文档的编写上，还能被用来编写电子书，或者用于论坛上发表消息，我们平时写博客也都使用 Markdown 语言。<a id="more"></a>  </p>
<hr>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown 标题有两种格式<br>1.使用 <code>=</code> 和 <code>-</code> 标记一级标题和二级标题   </p>
<blockquote>
<p>一级标题<br>=<br>二级标题<br>-                              </p>
</blockquote>
<p>  <strong>注意上面的 <code>-</code> 和 <code>=</code> 可以写一个也可以写多个!!!</strong><br>显示效果如下：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p>2.使用 <code>#</code> 标记  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题  </span><br><span class="line">## 二级标题  </span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题  </span><br><span class="line">##### 五级标题  </span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<p>显示效果如下：  </p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<hr>
<hr>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>Markdown 段落没有什么特殊格式，直接编写文档便可，换行时用两个以上的<code>空格</code>加上<code>回车</code>，或者可以在段落后面使用一个空行来表示重新开始一个段落<br><img src="/images/artic/mdyf01/img-01.png" alt="截图">  </p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>
<p>显示如下：  </p>
<blockquote>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong>  </p>
</blockquote>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在它们中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">_ _ _</span><br></pre></td></tr></table></figure>
<p>显示效果如下： </p>
<blockquote>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <code>~~</code> 即可  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无删除线  </span><br><span class="line">~~有删除线~~</span><br></pre></td></tr></table></figure>
<p>显示效果如下所示：  </p>
<blockquote>
<p>无删除线<br><del>有删除线</del>  </p>
</blockquote>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：</p>
<p><code>&lt;u&gt;带下划线&lt;/u&gt;</code><br>显示效果如下所示：  </p>
<blockquote>
<p><u>带下划线</u>  </p>
</blockquote>
<hr>
<h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><p>Markdown 支持有序列表和无序列表。</p>
<p>1.无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项  </span><br><span class="line">+ 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure>
<p>注意星号(*)、加号(+)或是减号(-)后面要有一个空格，显示效果如下：  </p>
<blockquote>
<ul>
<li>第一项  </li>
<li>第二项  </li>
</ul>
<ul>
<li>第三项  </li>
</ul>
</blockquote>
<p>2.有序列表使用数字并加上 . 号来表示，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure>
<p>显示结果如下：  </p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<p>3.列表嵌套<br>列表嵌套只需在子列表中的选项前添加四个空格即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>
<p>显示结果如下：  </p>
<blockquote>
<ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
</blockquote>
<hr>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 <code>&gt;</code> 符号 ，然后后面紧跟一个<code>空格</code>符号,而且区块是可以嵌套的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块  </span><br><span class="line">&gt; 区块</span><br><span class="line">&gt;&gt; 第一层嵌套区块  </span><br><span class="line">&gt;&gt; 第一层嵌套区块</span><br><span class="line">&gt;&gt;&gt; 第二层嵌套区块  </span><br><span class="line">&gt;&gt;&gt; 第二层嵌套区块</span><br></pre></td></tr></table></figure>
<p>显示效果：  </p>
<blockquote>
<p>区块<br>区块</p>
<blockquote>
<p>第一层嵌套区块<br>第一层嵌套区块</p>
<blockquote>
<p>第二层嵌套区块<br>第二层嵌套区块  </p>
</blockquote>
</blockquote>
</blockquote>
<p>不想写在区块中的内容要空一行在写，不然也会在区块中显示。 </p>
<h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表直接在区块语法后接列表语法即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块中使用列表    </span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; + 第一项    </span><br><span class="line">&gt; + 第二项 </span><br><span class="line">&gt; + 第三项</span><br></pre></td></tr></table></figure>
<p>显示结果如下：  </p>
<blockquote>
<p>区块中使用列表    </p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项    </li>
<li>第二项 </li>
<li>第三项</li>
</ul>
</blockquote>
<h3 id="在列表中使用区块"><a href="#在列表中使用区块" class="headerlink" title="在列表中使用区块"></a>在列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 <code>&gt;</code> 前添加四个空格的缩进。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">    &gt; 菜鸟教程</span><br><span class="line">    &gt; 学的不仅是技术更是梦想</span><br><span class="line">* 第二项</span><br></pre></td></tr></table></figure>
<p>显示结果如下：  </p>
<ul>
<li>第一项<blockquote>
<p>区块内容<br>区块内容</p>
</blockquote>
</li>
<li>第二项<blockquote>
<p>区块内容<br>区块内容</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或代码片段可以用反引号 ` 把它包起来:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 &#96;alert()&#96; 函数</span><br></pre></td></tr></table></figure>
<p>显示如下：  </p>
<p>使用 <code>alert()</code> 函数</p>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 4 个空格或者一个制表符（tab 键），代码区块上下文都要空一行 </p>
<p><img src="/images/artic/mdyf01/img-02.png" alt="截图">  </p>
<p>显示效果如下：</p>
<pre><code>function sayHello() {
  alert(&quot;你好啊！&quot;);
}</code></pre><p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）</p>
<p><img src="/images/artic/mdyf01/img-03.png" alt="截图"></p>
<p>显示结果如下： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'你好啊！'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接使用方法如下：</p>
<blockquote>
<p>[链接名称](链接地址)</p>
<p>或者</p>
<p>&lt;链接地址&gt;  </p>
</blockquote>
<p>例如：  </p>
<p>[百度一下](<code>https://www.baidu.com/</code>)</p>
<p>&lt;<code>https://www.baidu.com/</code>&gt;</p>
<p>显示如下： </p>
<blockquote>
<p><a href="https://www.baidu.com/" target="_blank" rel="noopener external nofollow noreferrer">百度一下</a>   </p>
<p><a href="https://www.baidu.com/" target="_blank" rel="noopener external nofollow noreferrer">https://www.baidu.com/</a>  </p>
</blockquote>
<h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>链接也可以用变量来代替，文档末尾附带变量地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [百度一下][1]</span><br><span class="line">这个链接用 runoob 作为网址变量 [百度一下][baidu]</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">[1]: https:&#x2F;&#x2F;www.baidu.com&#x2F;</span><br><span class="line">[baidu]: https:&#x2F;&#x2F;www.baidu.com&#x2F;</span><br></pre></td></tr></table></figure>
<p>显示结果如下：  </p>
<blockquote>
<p>这个链接用 1 作为网址变量 <a href="https://www.baidu.com/" target="_blank" rel="noopener external nofollow noreferrer">百度一下</a><br>这个链接用 runoob 作为网址变量 <a href="https://www.baidu.com/" target="_blank" rel="noopener external nofollow noreferrer">百度一下</a>，然后在文档的结尾为变量赋值（网址）。  </p>
</blockquote>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 图片语法格式如下：</p>
<p>![<code>图片的替代文字</code>](<code>图片地址</code>)</p>
<p>![<code>图片的替代文字</code>](<code>图片地址</code> <code>&quot;可选标题&quot;</code>)<br>方括号里面是图片的替代文字（图片加载不出来时显示），括号里面是图片的网址，后面还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br>例如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![狗狗](&#x2F;images&#x2F;artic&#x2F;mdyf01&#x2F;img-01.jpg)</span><br></pre></td></tr></table></figure>

<p>显示如下：<br><img src="/images/artic/mdyf01/img-01.jpg" alt="狗狗">   </p>
<p>也可以对图片网址使用变量：<br>这个链接用 dog 作为网址变量 <a href="/images/artic/mdyf01/img-01.jpg">狗狗</a>，然后在文档的结尾为变量赋值（网址）</p>
<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签,在外面加上 <code>&lt;div&gt;</code> 标签，配上 align=center 属性还可以居中。</p>
<p><code>&lt;div align=center&gt;&lt;img src=&quot;/images/artic/mdyf01/img-02.jpg&quot; width=&quot;400&quot;&gt;&lt;/div&gt;</code></p>
<p>显示结果如下：</p>
<div align=center><img src="/images/artic/mdyf01/img-02.jpg" width="400"></div>

<hr>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 表头  | 表头  | 表头  |</span><br><span class="line">| ----  | ---- | ----  |</span><br><span class="line">| 单元格 |单元格| 单元格 |</span><br><span class="line">| 单元格 |单元格| 单元格 |</span><br></pre></td></tr></table></figure>
<p>显示效果如下：  </p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<p>我们可以设置表格的对齐方式：</p>
<blockquote>
<p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。  </p>
</blockquote>
<p>例如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 居中 | 右对齐 |</span><br><span class="line">| :---  | :--: | ---:  |</span><br><span class="line">| 单元格 |单元格| 单元格 |</span><br><span class="line">| 单元格 |单元格| 单元格 |</span><br></pre></td></tr></table></figure>
<p>显示如下：  </p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="center">单元格</td>
<td align="right">单元格</td>
</tr>
</tbody></table>
<hr>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="1-支持的-HTML-元素"><a href="#1-支持的-HTML-元素" class="headerlink" title="1.支持的 HTML 元素"></a>1.支持的 HTML 元素</h3><p>目前支持的 HTML 元素有：&lt;kbd&gt; 、&lt;br&gt; 、&lt;i&gt; 、&lt;em&gt; 、&lt;sup&gt; 、&lt;sub&gt; 、&lt;br&gt; 等<br>例如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按键&lt;kbd&gt;Enter&lt;&#x2F;kbd&gt;  &lt;b&gt;加粗b&lt;&#x2F;b&gt;  &lt;i&gt;文本i&lt;&#x2F;i&gt;  &lt;em&gt;斜体em&lt;&#x2F;em&gt;   </span><br><span class="line">上标&lt;sup&gt;sup&lt;&#x2F;sup&gt;  下标&lt;sub&gt;sub&lt;&#x2F;sub&gt;  &lt;br&gt;换行br&lt;&#x2F;br&gt;</span><br></pre></td></tr></table></figure>

<p>按键<kbd>Enter</kbd>  <b>加粗b</b>  <i>文本i</i>  <em>斜体em</em><br>上标<sup>sup</sup>  下标<sub>sub</sub>  <br>换行br</p>
<p>还有其他的技巧以后熟悉了再和大家分享。。。</p>
]]></content>
      <tags>
        <tag>MrakDown</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hexo + GitHub 搭建自己的个人博客</title>
    <url>/2020/02/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用 Hexo + GitHub 免费搭建自己的个人博客，平时当做自己学习记笔记的地方，也可以锻炼自己写博客和编程的能力  </p>
<a id="more"></a>
<h2 id="一、安装前提"><a href="#一、安装前提" class="headerlink" title="一、安装前提"></a>一、安装前提</h2><blockquote>
<p>1.你的电脑已经安装好Git。<br> 2.你的电脑已经安装好Node.js，安装镜像换成国内的[^淘宝镜像]下载会更快一些。  </p>
</blockquote>
<hr>
<h2 id="二、安装-Hexo"><a href="#二、安装-Hexo" class="headerlink" title="二、安装 Hexo"></a>二、安装 Hexo</h2><blockquote>
<p>如果已安装淘宝镜像 可以使用 cnpm 来安装 Hexo ， 否则使用 npm  </p>
</blockquote>
<ul>
<li>打开 Git Bash ，输入以下命令：<br>  <code>$ npm install -g hexo-cli</code>  </li>
<li>等 hexo 安装完成后，输入：<br>  <code>$ hexo -v</code>  </li>
<li>查看 hexo 的版本信息。<br><img src="/images/artic/blog01/img-2.png" alt="截图">  </li>
</ul>
<hr>
<h2 id="三、使用-Hexo-创建我们的博客"><a href="#三、使用-Hexo-创建我们的博客" class="headerlink" title="三、使用 Hexo 创建我们的博客"></a>三、使用 Hexo 创建我们的博客</h2><blockquote>
<ul>
<li>可以在你想创建个人博客的文件夹里创建一个 blog 文件夹，在里面右键打开 Git Bash ，输入：<br>  <code>$ hexo init</code><br>初始化项目，<br><img src="/images/artic/blog01/img-3.png" alt="截图"></li>
<li>初始化完成后会在 blog 文件夹生成一系列文件（hexo 模板），<br><img src="/images/artic/blog01/img-4.png" alt="截图"><br>这个过程可能比较久，如果失败的话，可以把 blog 文件夹里的东西都删除了，再重复上一步，输入<br>  <code>$ hexo init</code>  </li>
<li>我们做博客都是围绕这些文件来做。这时候就可以启动我们的博客了，输入：<br>  <code>$ hexo s</code><br><img src="/images/artic/blog01/img-5.png" alt="截图"></li>
<li>在我们的浏览器中输入 localhost:4000 ,即可打开我们初始化的博客<br><img src="/images/artic/blog01/img-6.png" alt="截图">  </li>
</ul>
</blockquote>
<hr>
<h2 id="四、把我们的博客部署到-GitHub-上"><a href="#四、把我们的博客部署到-GitHub-上" class="headerlink" title="四、把我们的博客部署到 GitHub 上"></a>四、把我们的博客部署到 GitHub 上</h2><blockquote>
<p>1.在我们的 GitHub 上新建一个项目，项目名是你 GitHub 的用户名，例如我的GitHub用户名为 1914k 那么我就创建一个名字为：1914k.github.io 的项目<br><img src="/images/artic/blog01/img-7.png" alt="截图"><br>2.安装 git 部署的插件，输入：<br>    <code>$ npm install --save hexo-deployer-git</code><br>3.打开 blog 文件夹里的 _config.yml 配置文件，<br><img src="/images/artic/blog01/img-8.png" alt="截图"><br>翻到最下面，找到 deploy: ，将 type 改成 git ，把 repo 的地址换成自己的 GitHub 博客地址，如下：<br><img src="/img/artic/blog01/img-9.png" alt="截图"><br><strong>注意/!这里的格式不能错，该有的空格要有</strong><br><strong>type，repository，branch的首字母要对齐</strong><br>4.最后输入以下三个命令：<br>    <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ hexo clean  <span class="comment">//清理一下</span></span><br><span class="line">$ hexo g      <span class="comment">//重新生成一下</span></span><br><span class="line">$ hexo d      <span class="comment">//部署到远端</span></span><br></pre></td></tr></table></figure><br>我们的博客就成功的部署到 GitHub 上了， 可以在浏览器输入<a href="https://1914k.github.io/">https://1914k.github.io/</a> 网址打开我们的博客。<br>[^淘宝镜像]: 这里是脚注</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
